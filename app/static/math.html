<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>数学演習モード</title>
  <style>
    body{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;margin:0;background:#0f172a;color:#e5e7eb;}
    main{max-width:720px;margin:0 auto;padding:24px;}
    h1{margin-top:0;}
    .card{background:#111827;border:1px solid #1f2937;border-radius:16px;padding:20px;margin-bottom:16px;}
    button{background:#2563eb;border:1px solid #2563eb;border-radius:10px;color:#fff;padding:10px 18px;font-size:16px;cursor:pointer;}
    button:disabled{opacity:.5;cursor:not-allowed;}
    input{width:100%;padding:12px;border-radius:10px;border:1px solid #334155;background:#0b1220;color:#e5e7eb;font-size:16px;}
    .field-stack{display:flex;flex-direction:column;gap:12px;margin-top:16px;}
    .field-row{display:flex;flex-direction:row;align-items:center;gap:12px;flex-wrap:wrap;}
    .field-label{font-size:14px;color:#94a3b8;}
    .field-row input{width:8ch;flex:0 0 auto;padding:8px 10px;}
    .field-unit{font-size:14px;color:#94a3b8;}
    #feedback{margin-top:12px;min-height:2.2em;}
    .muted{color:#94a3b8;}
    .ok{color:#22c55e;}
    .ng{color:#ef4444;}
  </style>
</head>
<body>
  <main>
    <div class="card">
      <h1>数学演習モード</h1>
      <p class="muted">入力欄に解答を入力して「答え合わせ」を押してください。複数の欄が表示された場合はそれぞれの欄に1つずつ値を入力してください。</p>
    </div>
    <div class="card" id="quiz" style="display:none">
      <div id="question" style="font-size:18px;font-weight:600"></div>
      <div id="answer-inputs" class="field-stack"></div>
      <div style="display:flex;gap:12px;margin-top:16px;flex-wrap:wrap">
        <button id="btn-check">答え合わせ</button>
        <button id="btn-next" disabled>次の問題 ▶</button>
      </div>
      <div id="feedback" class="muted"></div>
    </div>
    <div class="card" id="loading">読み込み中…</div>
    <div class="card" id="error" style="display:none;color:#ef4444"></div>
  </main>
  <script>
    const QUESTIONS_URL = "/data/math_questions.json";
    const state = { questions: [], index: 0, graded: false, inputs: [], fieldSpecs: [] };

    function $(sel){ return document.querySelector(sel); }

    const normalizeDigits = value => (value == null ? '' : String(value).replace(/[０-９]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0)));
    function normalize(value){
      if(value == null) return '';
      return normalizeDigits(value)
        .trim()
        .replace(/\s*([=:=≒≈<>≤≥+\-*/])\s*/g, '$1')
        .replace(/\s+/g, ' ')
        .toLowerCase();
    }

    function asFieldSpec(raw, index){
      if(raw && typeof raw === 'object'){
        const key = raw.key || raw.name || `field${index}`;
        return {
          key,
          label: raw.label || raw.name || `入力${index + 1}`,
          placeholder: raw.placeholder || '',
          autocomplete: raw.autocomplete || 'off',
          autocapitalize: raw.autocapitalize || 'off',
          unit: raw.unit || ''
        };
      }
      if(typeof raw === 'string'){
        return {
          key: `field${index}`,
          label: raw,
          placeholder: '',
          autocomplete: 'off',
          autocapitalize: 'off',
          unit: ''
        };
      }
      return {
        key: `field${index}`,
        label: `入力${index + 1}`,
        placeholder: '',
        autocomplete: 'off',
        autocapitalize: 'off',
        unit: ''
      };
    }

    function inferFieldSpecs(question){
      if(!question) return [];
      const answers = getAnswerList(question);
      if(!answers.length) return [];

      const arrayCandidates = answers.filter(ans => Array.isArray(ans) && ans.length > 1);
      if(arrayCandidates.length){
        const targetLength = arrayCandidates[0].length;
        const consistentLength = arrayCandidates.every(ans => ans.length === targetLength);
        const hasOtherStructures = answers.some(ans => {
          if(ans == null) return false;
          if(Array.isArray(ans)) return false;
          if(typeof ans === 'string') return ans.trim() !== '';
          return true;
        });
        if(consistentLength && targetLength > 0 && !hasOtherStructures){
          return Array.from({ length: targetLength }, (_, idx) => ({
            key: `part${idx}`,
            label: `入力${idx + 1}`,
            placeholder: '',
            autocomplete: 'off',
            autocapitalize: 'off',
            unit: ''
          }));
        }
      }

      const objectCandidates = answers.filter(ans => ans && typeof ans === 'object' && !Array.isArray(ans));
      if(objectCandidates.length){
        const keySets = objectCandidates.map(obj => Object.keys(obj).sort());
        const referenceKeys = keySets[0] || [];
        const hasMultipleKeys = referenceKeys.length > 1;
        const consistentKeys = hasMultipleKeys && keySets.every(keys => {
          if(keys.length !== referenceKeys.length) return false;
          return keys.every((key, idx) => key === referenceKeys[idx]);
        });
        const hasMixedStructures = answers.some(ans => {
          if(ans == null) return false;
          if(typeof ans === 'object' && !Array.isArray(ans)) return false;
          return true;
        });
        if(consistentKeys && !hasMixedStructures){
          return referenceKeys.map(key => ({
            key,
            label: key,
            placeholder: '',
            autocomplete: 'off',
            autocapitalize: 'off',
            unit: ''
          }));
        }
      }

      return [];
    }

    function getFieldSpecs(question){
      if(!question) return [];
      if(Array.isArray(question.fields) && question.fields.length){
        return question.fields.map((raw, idx) => asFieldSpec(raw, idx));
      }
      return inferFieldSpecs(question);
    }

    function compareScalar(expected, actual){
      if(expected == null && actual == null) return true;
      if(expected == null || actual == null) return false;
      return normalize(String(expected)) === normalize(String(actual));
    }

    function matchesAnswer(candidate, userValues, fieldSpecs){
      if(Array.isArray(candidate)){
        if(candidate.length !== fieldSpecs.length) return false;
        return candidate.every((part, idx) => compareScalar(part, userValues[idx] || ''));
      }
      if(candidate && typeof candidate === 'object'){
        const userMap = new Map();
        fieldSpecs.forEach((field, idx) => {
          userMap.set(field.key, userValues[idx] || '');
        });
        return fieldSpecs.every(field => {
          if(!Object.prototype.hasOwnProperty.call(candidate, field.key)) return false;
          const expected = candidate[field.key];
          const actual = userMap.get(field.key);
          if(Array.isArray(expected)){
            return expected.some(option => compareScalar(option, actual));
          }
          return compareScalar(expected, actual);
        });
      }
      return compareScalar(candidate, userValues[0] || '');
    }

    function getAnswerList(question){
      const answers = Array.isArray(question.answers) ? question.answers.slice() : [];
      if(!answers.length && typeof question.answer === 'string'){
        answers.push(question.answer);
      }
      return answers;
    }

    function clearInputEventHandlers(){
      state.inputs.forEach(input => {
        input.removeEventListener('keydown', onInputKeyDown);
      });
    }

    function buildInputs(question){
      clearInputEventHandlers();
      const container = $('#answer-inputs');
      container.innerHTML = '';
      const specs = getFieldSpecs(question);
      const inputs = [];
      if(specs.length){
        specs.forEach((spec, idx) => {
          const wrapper = document.createElement('label');
          wrapper.className = 'field-row';
          const label = document.createElement('span');
          label.className = 'field-label';
          label.textContent = spec.label;
          const input = document.createElement('input');
          input.type = 'text';
          input.placeholder = spec.placeholder || '';
          input.autocomplete = spec.autocomplete || 'off';
          input.autocapitalize = spec.autocapitalize || 'off';
          input.dataset.index = String(idx);
          wrapper.appendChild(label);
          wrapper.appendChild(input);
          if(spec.unit){
            const unit = document.createElement('span');
            unit.className = 'field-unit';
            unit.textContent = spec.unit;
            wrapper.appendChild(unit);
          }
          container.appendChild(wrapper);
          inputs.push(input);
        });
      } else {
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = '解答を入力';
        input.autocomplete = 'off';
        input.autocapitalize = 'off';
        input.dataset.index = '0';
        container.appendChild(input);
        inputs.push(input);
      }
      inputs.forEach(input => input.addEventListener('keydown', onInputKeyDown));
      state.inputs = inputs;
      state.fieldSpecs = specs;
    }

    function getUserValues(){
      if(!state.inputs.length) return [''];
      return state.inputs.map(input => input.value || '');
    }

    function onInputKeyDown(ev){
      if(ev.key === 'Enter'){
        ev.preventDefault();
        if(state.graded){
          nextQuestion();
        } else {
          checkAnswer();
        }
      }
    }

    function renderQuestion(){
      if(!state.questions.length){
        $('#quiz').style.display = 'none';
        $('#loading').textContent = '問題が見つかりませんでした。';
        return;
      }
      const q = state.questions[state.index];
      $('#question').textContent = q.prompt || q.question || '';
      buildInputs(q);
      state.inputs.forEach(input => { input.value = ''; });
      $('#feedback').textContent = '';
      $('#feedback').className = 'muted';
      state.graded = false;
      $('#btn-next').disabled = true;
      $('#quiz').style.display = '';
      $('#loading').style.display = 'none';
      if(state.inputs[0]){
        state.inputs[0].focus();
      }
    }

    function checkAnswer(){
      if(state.graded) return;
      const q = state.questions[state.index];
      const userValues = getUserValues();
      const fieldSpecs = state.fieldSpecs;
      const answers = getAnswerList(q);
      if(!answers.length){
        $('#feedback').className = 'muted';
        $('#feedback').textContent = '正解が登録されていません。';
        state.graded = true;
        $('#btn-next').disabled = false;
        return;
      }
      const isCorrect = answers.some(candidate => matchesAnswer(candidate, userValues, fieldSpecs));
      state.graded = true;
      $('#btn-next').disabled = false;
      if(isCorrect){
        $('#feedback').className = 'ok';
        $('#feedback').innerHTML = `✅ 正解です！`;
      } else {
        $('#feedback').className = 'ng';
        const formatted = answers
          .map(ans => {
            if(Array.isArray(ans)){
              if(fieldSpecs.length > 1){
                return ans.join(' / ');
              }
              return ans.join(' ');
            }
            if(ans && typeof ans === 'object'){
              return fieldSpecs.map(field => ans[field.key]).filter(Boolean).join(' / ');
            }
            return ans;
          })
          .join('<br><span class="muted">または</span> ');
        $('#feedback').innerHTML = `❌ 不正解。 正解例: ${formatted}`;
      }
    }

    function nextQuestion(){
      if(!state.graded) checkAnswer();
      state.index = (state.index + 1) % state.questions.length;
      renderQuestion();
    }

    $('#btn-check').addEventListener('click', checkAnswer);
    $('#btn-next').addEventListener('click', nextQuestion);
    fetch(QUESTIONS_URL, { cache: 'no-store' })
      .then(res => {
        if(!res.ok) throw new Error(`fetch ${QUESTIONS_URL} ${res.status}`);
        return res.json();
      })
      .then(data => {
        state.questions = Array.isArray(data.questions) ? data.questions : [];
        $('#loading').style.display = 'none';
        if(!state.questions.length){
          $('#loading').style.display = '';
          $('#loading').textContent = '問題が見つかりませんでした。';
          return;
        }
        renderQuestion();
      })
      .catch(err => {
        $('#loading').style.display = 'none';
        const box = $('#error');
        box.style.display = '';
        box.textContent = `問題の読み込みに失敗しました: ${err.message}`;
      });
  </script>
</body>
</html>
