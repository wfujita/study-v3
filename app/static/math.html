<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>数学演習モード</title>
  <style>
    body{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;margin:0;background:#0f172a;color:#e5e7eb;}
    main{max-width:760px;margin:0 auto;padding:24px;}
    h1{margin-top:0;}
    .card{background:#111827;border:1px solid #1f2937;border-radius:16px;padding:20px;margin-bottom:16px;}
    .card-header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;}
    button{background:#2563eb;border:1px solid #2563eb;border-radius:10px;color:#fff;padding:10px 18px;font-size:16px;cursor:pointer;}
    button:disabled{opacity:.5;cursor:not-allowed;}
    input,select{width:100%;padding:12px;border-radius:10px;border:1px solid #334155;background:#0b1220;color:#e5e7eb;font-size:16px;}
    .field-stack{display:flex;flex-direction:column;gap:12px;margin-top:16px;}
    .field-row{display:flex;flex-direction:row;align-items:center;gap:12px;flex-wrap:wrap;}
    .field-label{font-size:14px;color:#94a3b8;}
    .field-row input{width:8ch;flex:0 0 auto;padding:8px 10px;}
    .field-unit{font-size:14px;color:#94a3b8;}
    #feedback{margin-top:12px;min-height:2.2em;}
    .muted{color:#94a3b8;}
    .ok{color:#22c55e;}
    .ng{color:#ef4444;}
    .question-header{display:flex;align-items:flex-start;justify-content:space-between;gap:12px;flex-wrap:wrap;}
    .question-tags{display:flex;align-items:center;justify-content:flex-end;gap:8px;flex-wrap:wrap;}
    .badge{display:inline-flex;align-items:center;justify-content:center;padding:4px 10px;border-radius:9999px;font-size:12px;font-weight:600;letter-spacing:.05em;text-transform:uppercase;}
    .badge-normal{background:rgba(37,99,235,.15);color:#93c5fd;border:1px solid rgba(59,130,246,.4);}
    .badge-hard{background:rgba(236,72,153,.15);color:#f9a8d4;border:1px solid rgba(244,114,182,.4);}
    .status-text{font-size:14px;}
    .status-success{color:#4ade80;}
    .status-error{color:#f87171;}
    .field-note{font-size:14px;color:#94a3b8;margin:0;}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 12px;border-radius:9999px;background:#1e293b;border:1px solid #334155;color:#cbd5e1;font-size:13px;font-weight:600;}
    a.link{color:#93c5fd;text-decoration:none;}
    a.link:hover{text-decoration:underline;}
  </style>
</head>
<body>
  <main>
    <div class="card" id="setup-card">
      <div class="card-header">
        <h1 style="margin:0">数学演習モード</h1>
        <div id="user-pill" class="pill">👤 ゲスト</div>
      </div>
      <p class="muted">出題レベルを選んで問題に挑戦し、表示された解答欄に入力してから採点してください。複数の欄が表示された場合はそれぞれの欄に1つずつ値を入力してください。</p>
      <div class="field-stack">
        <label class="field-label" for="learner-name">学習者名</label>
        <input id="learner-name" type="text" placeholder="taro" autocomplete="off" autocapitalize="off" list="user-suggestions" />
        <datalist id="user-suggestions"></datalist>
        <p class="field-note">入力した名前が提出記録に保存されます。空欄のままの場合はゲストとして記録されます。</p>
      </div>
      <div class="field-stack">
        <label class="field-label" for="difficulty-select">出題レベル</label>
        <select id="difficulty-select">
          <option value="normal">標準</option>
          <option value="hard">難問</option>
        </select>
        <p class="field-note">難問を選ぶと文章題など発展的な問題のみが出題されます。</p>
      </div>
      <div class="field-stack">
        <label class="field-label" for="question-count-select">出題する問題数</label>
        <select id="question-count-select">
          <option value="1" selected>1問</option>
          <option value="2">2問</option>
          <option value="3">3問</option>
        </select>
        <p class="field-note">選択した難易度で出題される問題数を指定できます（最大3問）。</p>
      </div>
      <div class="field-stack" style="margin-top:16px">
        <button id="btn-start" disabled>問題を読み込んでいます…</button>
        <p class="field-note" id="start-note">問題の読み込みが完了したら演習を開始できます。</p>
      </div>
      <p class="field-note" style="margin-top:16px"><a class="link" href="/math-results.html">提出履歴を確認する</a></p>
    </div>
    <div class="card" id="quiz" style="display:none">
      <div style="display:flex;justify-content:flex-end;margin-bottom:12px">
        <button id="btn-change-settings" style="background:#1e293b;border-color:#1e293b;color:#cbd5e1">⚙️ 出題条件を変更</button>
      </div>
      <div class="question-header">
        <div id="question" style="font-size:18px;font-weight:600"></div>
        <div class="question-tags">
          <span id="difficulty-badge" class="badge badge-normal">標準</span>
          <span id="question-stage" class="pill" style="display:none"></span>
        </div>
      </div>
      <div id="question-meta" class="muted" style="font-size:13px;margin-top:4px;min-height:1.2em"></div>
      <div id="answer-inputs" class="field-stack"></div>
      <div style="display:flex;gap:12px;margin-top:16px;flex-wrap:wrap">
        <button id="btn-check">答え合わせ</button>
        <button id="btn-next" disabled>次の問題 ▶</button>
      </div>
      <div id="feedback" class="muted"></div>
      <div id="save-status" class="status-text muted" aria-live="polite" style="margin-top:8px;min-height:1.4em"></div>
    </div>
    <div class="card" id="loading">読み込み中…</div>
    <div class="card" id="error" style="display:none;color:#ef4444"></div>
  </main>
  <script>
    const SUBJECT = 'math';
    const QUESTIONS_URL = "/data/math/questions.json";
    const RESULT_ENDPOINT = '/api/results';
    const REMEMBER_USER_KEY = 'quiz:lastUser';
    const USER_SUGGEST_KEY = 'quiz:userList';
    const state = {
      allQuestions: [],
      questions: [],
      index: 0,
      graded: false,
      inputs: [],
      fieldSpecs: [],
      sessionId: null,
      attempt: 0,
      difficulty: 'normal',
      questionCount: '1',
      started: false,
      user: 'guest',
      stageMeta: [],
    };

    const MIN_QUESTION_COUNT = 1;
    const MAX_QUESTION_COUNT = 3;
    const STAGE_PRIORITY = ['A','B','C','D','E'];

    const shuffle = arr => Array.isArray(arr)
      ? arr.map(value => ({ value, sort: Math.random() }))
            .sort((a, b) => a.sort - b.sort)
            .map(item => item.value)
      : [];

    function parseIsoDate(value){
      if(!value) return null;
      const date = new Date(value);
      return Number.isNaN(date.getTime()) ? null : date;
    }

    function normalizeStage(value){
      if(typeof value !== 'string') return 'F';
      const upper = value.trim().toUpperCase();
      if(STAGE_PRIORITY.includes(upper) || upper === 'F') return upper;
      return 'F';
    }

    function willStageUpOnSuccess(stage, nextDue, nowMs){
      if(!STAGE_PRIORITY.includes(stage)) return false;
      if(stage === 'A') return false;
      if(!(nextDue instanceof Date)) return true;
      return nextDue.getTime() <= nowMs;
    }

    function formatAccuracy(correct, answered){
      const c = Number(correct);
      const a = Number(answered);
      if(!Number.isFinite(c) || !Number.isFinite(a) || a <= 0) return null;
      return (c / a) * 100;
    }

    function describeNextDue(nextDueStr){
      const dt = parseIsoDate(nextDueStr);
      if(!dt) return '';
      try{
        return new Intl.DateTimeFormat('ja-JP', {
          month: 'numeric',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        }).format(dt);
      }catch(err){
        return dt.toISOString().replace('T', ' ').slice(0, 16);
      }
    }

    let rankingRequestId = 0;

    function $(sel){ return document.querySelector(sel); }

    function sanitizeUserName(value){
      if(value == null) return '';
      return String(value).trim().replace(/\s+/g, ' ').slice(0, 60);
    }

    function getEffectiveUserName(value){
      const sanitized = sanitizeUserName(value);
      if(!sanitized) return 'guest';
      if(sanitized.toLowerCase() === 'math') return 'guest';
      return sanitized;
    }

    function displayUserName(value){
      const sanitized = sanitizeUserName(value);
      if(!sanitized || sanitized.toLowerCase() === 'guest' || sanitized.toLowerCase() === 'math'){
        return 'ゲスト';
      }
      return sanitized;
    }

    function updateUserPill(userValue){
      if(!userPill) return;
      userPill.textContent = `👤 ${displayUserName(userValue)}`;
    }

    function getStoredUserList(){
      try{
        const raw = localStorage.getItem(USER_SUGGEST_KEY) || '[]';
        const parsed = JSON.parse(raw);
        if(Array.isArray(parsed)){
          return parsed
            .map(name => sanitizeUserName(name))
            .filter(name => !!name);
        }
      }catch(err){
        // ignore storage errors
      }
      return [];
    }

    function writeStoredUserList(list){
      try{
        const limited = list.slice(0, 20);
        localStorage.setItem(USER_SUGGEST_KEY, JSON.stringify(limited));
      }catch(err){
        // ignore storage errors
      }
    }

    function populateUserSuggestions(){
      const datalist = document.getElementById('user-suggestions');
      if(!datalist) return;
      const list = getStoredUserList();
      datalist.innerHTML = '';
      list.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        datalist.appendChild(opt);
      });
    }

    function rememberUserName(name){
      const trimmed = sanitizeUserName(name);
      if(!trimmed) return;
      const list = getStoredUserList();
      const existingIndex = list.indexOf(trimmed);
      if(existingIndex !== -1){
        list.splice(existingIndex, 1);
      }
      list.unshift(trimmed);
      writeStoredUserList(list);
    }

    function setUser(raw, { remember = false } = {}){
      const sanitized = sanitizeUserName(raw);
      state.user = sanitized || 'guest';
      if(learnerInput){
        learnerInput.value = sanitized;
      }
      updateUserPill(state.user);
      if(remember){
        try{
          localStorage.setItem(REMEMBER_USER_KEY, sanitized);
        }catch(err){
          // ignore storage errors
        }
        if(sanitized){
          rememberUserName(sanitized);
        }
        populateUserSuggestions();
      }
    }

    function initializeUser(){
      let stored = '';
      try{
        stored = localStorage.getItem(REMEMBER_USER_KEY) || '';
      }catch(err){
        stored = '';
      }
      setUser(stored, { remember: false });
      populateUserSuggestions();
    }

    const difficultySelect = $('#difficulty-select');
    const difficultyBadge = $('#difficulty-badge');
    const questionStagePill = $('#question-stage');
    const questionMetaEl = $('#question-meta');
    const startButton = $('#btn-start');
    const startNote = $('#start-note');
    const setupCard = $('#setup-card');
    const quizCard = $('#quiz');
    const loadingCard = $('#loading');
    const errorCard = $('#error');
    const saveStatusEl = $('#save-status');
    const changeSettingsButton = $('#btn-change-settings');
    const questionCountSelect = $('#question-count-select');
    const learnerInput = $('#learner-name');
    const userPill = $('#user-pill');

    initializeUser();

    if(learnerInput){
      const applyUserInput = () => setUser(learnerInput.value, { remember: true });
      learnerInput.addEventListener('change', applyUserInput);
      learnerInput.addEventListener('blur', applyUserInput);
      learnerInput.addEventListener('keydown', ev => {
        if(ev.key === 'Enter'){
          ev.preventDefault();
          applyUserInput();
        }
      });
    }

    function setSaveStatus(message, status = 'muted'){
      if(!saveStatusEl) return;
      const classes = ['status-text'];
      if(status === 'success'){
        classes.push('status-success');
      } else if(status === 'error'){
        classes.push('status-error');
      } else {
        classes.push('muted');
      }
      saveStatusEl.className = classes.join(' ');
      saveStatusEl.textContent = message || '';
    }

    function normalizeDifficulty(value){
      const text = (value == null ? '' : String(value)).toLowerCase();
      return text === 'hard' ? 'hard' : 'normal';
    }

    function labelForDifficulty(level){
      return normalizeDifficulty(level) === 'hard' ? '難問' : '標準';
    }

    function updateDifficultyBadge(level){
      if(!difficultyBadge) return;
      const normalized = normalizeDifficulty(level);
      difficultyBadge.textContent = labelForDifficulty(normalized);
      difficultyBadge.className = `badge ${normalized === 'hard' ? 'badge-hard' : 'badge-normal'}`;
    }

    function filterQuestionsByDifficulty(level){
      const normalized = normalizeDifficulty(level);
      return state.allQuestions.filter(q => normalizeDifficulty(q && q.difficulty) === normalized);
    }

    function normalizeQuestionCount(value){
      const text = value == null ? '' : String(value).trim();
      const num = Number(text);
      if(!Number.isFinite(num)){
        return String(MIN_QUESTION_COUNT);
      }
      const clamped = Math.min(MAX_QUESTION_COUNT, Math.max(MIN_QUESTION_COUNT, Math.floor(num)));
      return String(clamped);
    }

    function limitQuestions(questions, count){
      const list = Array.isArray(questions) ? questions.slice() : [];
      if(!list.length) return list;
      const numeric = Number(count);
      if(!Number.isFinite(numeric) || numeric <= 0) return list;
      const capped = Math.min(MAX_QUESTION_COUNT, Math.max(MIN_QUESTION_COUNT, Math.floor(numeric)));
      const limit = Math.min(list.length, capped);
      return list.slice(0, limit);
    }

    if(questionCountSelect){
      questionCountSelect.value = state.questionCount;
      questionCountSelect.addEventListener('change', ev => {
        setQuestionCount(ev.target.value);
      });
    }
    if(difficultySelect){
      difficultySelect.value = state.difficulty;
      difficultySelect.addEventListener('change', ev => {
        const selected = ev.target.value;
        if(state.allQuestions.length){
          setDifficulty(selected);
        } else {
          state.difficulty = normalizeDifficulty(selected);
        }
      });
    }

    const normalizeDigits = value => (value == null ? '' : String(value).replace(/[０-９]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0)));
    function normalize(value){
      if(value == null) return '';
      return normalizeDigits(value)
        .trim()
        .replace(/\s*([=:=≒≈<>≤≥+\-*/])\s*/g, '$1')
        .replace(/\s+/g, ' ')
        .toLowerCase();
    }

    function asFieldSpec(raw, index){
      if(raw && typeof raw === 'object'){
        const key = raw.key || raw.name || `field${index}`;
        return {
          key,
          label: raw.label || raw.name || `入力${index + 1}`,
          placeholder: raw.placeholder || '',
          autocomplete: raw.autocomplete || 'off',
          autocapitalize: raw.autocapitalize || 'off',
          unit: raw.unit || ''
        };
      }
      if(typeof raw === 'string'){
        return {
          key: `field${index}`,
          label: raw,
          placeholder: '',
          autocomplete: 'off',
          autocapitalize: 'off',
          unit: ''
        };
      }
      return {
        key: `field${index}`,
        label: `入力${index + 1}`,
        placeholder: '',
        autocomplete: 'off',
        autocapitalize: 'off',
        unit: ''
      };
    }

    function inferFieldSpecs(question){
      if(!question) return [];
      const answers = getAnswerList(question);
      if(!answers.length) return [];

      const arrayCandidates = answers.filter(ans => Array.isArray(ans) && ans.length > 1);
      if(arrayCandidates.length){
        const targetLength = arrayCandidates[0].length;
        const consistentLength = arrayCandidates.every(ans => ans.length === targetLength);
        const hasOtherStructures = answers.some(ans => {
          if(ans == null) return false;
          if(Array.isArray(ans)) return false;
          if(typeof ans === 'string') return ans.trim() !== '';
          return true;
        });
        if(consistentLength && targetLength > 0 && !hasOtherStructures){
          return Array.from({ length: targetLength }, (_, idx) => ({
            key: `part${idx}`,
            label: `入力${idx + 1}`,
            placeholder: '',
            autocomplete: 'off',
            autocapitalize: 'off',
            unit: ''
          }));
        }
      }

      const objectCandidates = answers.filter(ans => ans && typeof ans === 'object' && !Array.isArray(ans));
      if(objectCandidates.length){
        const keySets = objectCandidates.map(obj => Object.keys(obj).sort());
        const referenceKeys = keySets[0] || [];
        const hasMultipleKeys = referenceKeys.length > 1;
        const consistentKeys = hasMultipleKeys && keySets.every(keys => {
          if(keys.length !== referenceKeys.length) return false;
          return keys.every((key, idx) => key === referenceKeys[idx]);
        });
        const hasMixedStructures = answers.some(ans => {
          if(ans == null) return false;
          if(typeof ans === 'object' && !Array.isArray(ans)) return false;
          return true;
        });
        if(consistentKeys && !hasMixedStructures){
          return referenceKeys.map(key => ({
            key,
            label: key,
            placeholder: '',
            autocomplete: 'off',
            autocapitalize: 'off',
            unit: ''
          }));
        }
      }

      return [];
    }

    function getFieldSpecs(question){
      if(!question) return [];
      if(Array.isArray(question.fields) && question.fields.length){
        return question.fields.map((raw, idx) => asFieldSpec(raw, idx));
      }
      return inferFieldSpecs(question);
    }

    function compareScalar(expected, actual){
      if(expected == null && actual == null) return true;
      if(expected == null || actual == null) return false;
      return normalize(String(expected)) === normalize(String(actual));
    }

    function matchesAnswer(candidate, userValues, fieldSpecs){
      if(Array.isArray(candidate)){
        if(candidate.length !== fieldSpecs.length) return false;
        return candidate.every((part, idx) => compareScalar(part, userValues[idx] || ''));
      }
      if(candidate && typeof candidate === 'object'){
        const userMap = new Map();
        fieldSpecs.forEach((field, idx) => {
          userMap.set(field.key, userValues[idx] || '');
        });
        return fieldSpecs.every(field => {
          if(!Object.prototype.hasOwnProperty.call(candidate, field.key)) return false;
          const expected = candidate[field.key];
          const actual = userMap.get(field.key);
          if(Array.isArray(expected)){
            return expected.some(option => compareScalar(option, actual));
          }
          return compareScalar(expected, actual);
        });
      }
      return compareScalar(candidate, userValues[0] || '');
    }

    function getAnswerList(question){
      const answers = Array.isArray(question.answers) ? question.answers.slice() : [];
      if(!answers.length && typeof question.answer === 'string'){
        answers.push(question.answer);
      }
      return answers;
    }

    function clearInputEventHandlers(){
      state.inputs.forEach(input => {
        input.removeEventListener('keydown', onInputKeyDown);
      });
    }

    function buildInputs(question){
      clearInputEventHandlers();
      const container = $('#answer-inputs');
      container.innerHTML = '';
      const specs = getFieldSpecs(question);
      const inputs = [];
      if(specs.length){
        specs.forEach((spec, idx) => {
          const wrapper = document.createElement('label');
          wrapper.className = 'field-row';
          const label = document.createElement('span');
          label.className = 'field-label';
          label.textContent = spec.label;
          const input = document.createElement('input');
          input.type = 'text';
          input.placeholder = spec.placeholder || '';
          input.autocomplete = spec.autocomplete || 'off';
          input.autocapitalize = spec.autocapitalize || 'off';
          input.dataset.index = String(idx);
          wrapper.appendChild(label);
          wrapper.appendChild(input);
          if(spec.unit){
            const unit = document.createElement('span');
            unit.className = 'field-unit';
            unit.textContent = spec.unit;
            wrapper.appendChild(unit);
          }
          container.appendChild(wrapper);
          inputs.push(input);
        });
      } else {
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = '解答を入力';
        input.autocomplete = 'off';
        input.autocapitalize = 'off';
        input.dataset.index = '0';
        container.appendChild(input);
        inputs.push(input);
      }
      inputs.forEach(input => input.addEventListener('keydown', onInputKeyDown));
      state.inputs = inputs;
      state.fieldSpecs = specs;
    }

    function getUserValues(){
      if(!state.inputs.length) return [''];
      return state.inputs.map(input => input.value || '');
    }

    function onInputKeyDown(ev){
      if(ev.key === 'Enter'){
        ev.preventDefault();
        if(state.graded){
          nextQuestion();
        } else {
          checkAnswer();
        }
      }
    }

    function showSetupView(){
      state.started = false;
      if(setupCard) setupCard.style.display = '';
      if(quizCard) quizCard.style.display = 'none';
      if(loadingCard) loadingCard.style.display = 'none';
      if(errorCard) errorCard.style.display = 'none';
      updateQuestionPool();
    }

    function updateStartNote(availableCount, limitedCount){
      if(!startNote) return;
      if(!availableCount || !limitedCount){
        startNote.textContent = '選択した難易度の問題が見つかりません。別の難易度を選んでください。';
        return;
      }
      let message = `開始を押すと${limitedCount}問が出題されます。`;
      const requested = Number(state.questionCount);
      if(Number.isFinite(requested) && requested > availableCount){
        message += `（利用可能な問題は${availableCount}問のみです。）`;
      }
      startNote.textContent = message;
    }

    async function rankQuestionsForUser(questions, rawUser, limit){
      const pool = Array.isArray(questions) ? questions.slice() : [];
      if(!pool.length){
        return { questions: [], meta: [] };
      }
      const effectiveUser = getEffectiveUserName(rawUser);
      const entries = pool.map((question, idx) => ({
        question,
        idx,
        id: question && question.id ? String(question.id) : null,
      }));

      const stats = await Promise.all(
        entries.map(entry => {
          if(!entry.id){
            return Promise.resolve(null);
          }
          const url = `/api/stats?user=${encodeURIComponent(effectiveUser)}&id=${encodeURIComponent(entry.id)}&subject=${encodeURIComponent(SUBJECT)}`;
          return fetch(url, { cache: 'no-store' })
            .then(res => (res.ok ? res.json() : null))
            .catch(() => null);
        })
      );

      const nowMs = Date.now();
      const dueByStage = new Map(STAGE_PRIORITY.map(stage => [stage, []]));
      const stageFPool = [];
      const waitingPool = [];
      const metaByIndex = new Map();

      entries.forEach((entry, idx) => {
        const stat = stats[idx];
        const meta = {
          stage: 'F',
          answered: 0,
          correct: 0,
          streak: 0,
          accuracy: null,
          nextDueAt: null,
        };

        if(stat && typeof stat === 'object'){
          const stage = normalizeStage(stat.stage);
          const answeredRaw = Number(stat.answered);
          const correctRaw = Number(stat.correct);
          const streakRaw = Number(stat.streak);
          const nextDueRaw = stat.nextDueAt || null;
          const nextDue = parseIsoDate(nextDueRaw);

          meta.stage = stage;
          meta.answered = Number.isFinite(answeredRaw) ? answeredRaw : 0;
          meta.correct = Number.isFinite(correctRaw) ? correctRaw : 0;
          meta.streak = Number.isFinite(streakRaw) ? streakRaw : 0;
          meta.accuracy = formatAccuracy(meta.correct, meta.answered);
          meta.nextDueAt = nextDueRaw;

          if(willStageUpOnSuccess(stage, nextDue, nowMs)){
            const bucket = dueByStage.get(stage);
            if(bucket){
              bucket.push({ entry, meta, nextDue, rand: Math.random() });
              metaByIndex.set(entry.idx, meta);
              return;
            }
          }

          if(stage === 'F' || !STAGE_PRIORITY.includes(stage)){
            stageFPool.push({ entry, meta, rand: Math.random() });
          } else {
            waitingPool.push({ entry, meta, nextDue, rand: Math.random() });
          }
        } else {
          stageFPool.push({ entry, meta, rand: Math.random() });
        }

        metaByIndex.set(entry.idx, meta);
      });

      const ordered = [];
      const chosen = new Set();

      for(const stage of STAGE_PRIORITY){
        const arr = dueByStage.get(stage) || [];
        arr.sort((a, b) => {
          const aDue = a.nextDue instanceof Date ? a.nextDue.getTime() : -Infinity;
          const bDue = b.nextDue instanceof Date ? b.nextDue.getTime() : -Infinity;
          if(aDue !== bDue) return aDue - bDue;
          return a.rand - b.rand;
        });
        for(const item of arr){
          const idx = item.entry.idx;
          if(chosen.has(idx)) continue;
          ordered.push({ question: item.entry.question, meta: { ...item.meta, stage } });
          chosen.add(idx);
        }
      }

      shuffle(stageFPool).forEach(item => {
        const idx = item.entry.idx;
        if(chosen.has(idx)) {
          return;
        }
        ordered.push({ question: item.entry.question, meta: { ...item.meta, stage: 'F' } });
        chosen.add(idx);
      });

      waitingPool.sort((a, b) => {
        const aDue = a.nextDue instanceof Date ? a.nextDue.getTime() : Infinity;
        const bDue = b.nextDue instanceof Date ? b.nextDue.getTime() : Infinity;
        if(aDue !== bDue) return aDue - bDue;
        return a.rand - b.rand;
      });
      waitingPool.forEach(item => {
        const idx = item.entry.idx;
        if(chosen.has(idx)) {
          return;
        }
        ordered.push({ question: item.entry.question, meta: { ...item.meta } });
        chosen.add(idx);
      });

      entries.forEach(entry => {
        if(chosen.has(entry.idx)) return;
        const meta = metaByIndex.get(entry.idx) || {
          stage: 'F',
          answered: 0,
          correct: 0,
          streak: 0,
          accuracy: null,
          nextDueAt: null,
        };
        ordered.push({ question: entry.question, meta: { ...meta } });
        chosen.add(entry.idx);
      });

      const desired = Number(limit);
      const maxCount = Number.isFinite(desired)
        ? Math.max(1, Math.min(ordered.length, Math.floor(desired)))
        : ordered.length;
      const selected = ordered.slice(0, maxCount);

      return {
        questions: selected.map(item => item.question),
        meta: selected.map(item => ({ ...item.meta })),
      };
    }

    function updateStageIndicators(meta){
      if(questionStagePill){
        if(meta && typeof meta.stage === 'string' && meta.stage){
          questionStagePill.style.display = '';
          questionStagePill.textContent = `ランク: ${meta.stage}`;
        } else {
          questionStagePill.style.display = 'none';
          questionStagePill.textContent = '';
        }
      }

      if(!questionMetaEl) return;
      if(!meta){
        questionMetaEl.textContent = '';
        return;
      }

      const answered = Number(meta.answered);
      const correct = Number(meta.correct);
      const streak = Number(meta.streak);
      const accuracy = typeof meta.accuracy === 'number' && Number.isFinite(meta.accuracy)
        ? meta.accuracy
        : null;
      const parts = [];

      if(Number.isFinite(answered) && answered > 0){
        const correctText = Number.isFinite(correct) ? correct : 0;
        const accuracyText = accuracy != null ? `${accuracy.toFixed(1)}%` : '';
        const segment = accuracyText
          ? `正解 ${correctText}/${answered}（${accuracyText}）`
          : `正解 ${correctText}/${answered}`;
        parts.push(segment);
      }

      if(Number.isFinite(streak) && streak > 0){
        parts.push(`連続正解 ${streak}`);
      }

      const nextDueText = describeNextDue(meta.nextDueAt);
      if(nextDueText){
        parts.push(`次回出題 ${nextDueText}`);
      }

      if(parts.length){
        questionMetaEl.textContent = parts.join('｜');
      } else if(Number.isFinite(answered) && answered === 0){
        questionMetaEl.textContent = 'この問題の履歴はまだありません。';
      } else {
        questionMetaEl.textContent = '';
      }
    }

    function updateQuestionPool(){
      const normalizedDifficulty = normalizeDifficulty(state.difficulty);
      if(difficultySelect){
        difficultySelect.value = normalizedDifficulty;
      }
      if(questionCountSelect){
        questionCountSelect.value = state.questionCount;
      }
      const available = filterQuestionsByDifficulty(normalizedDifficulty);

      if(!state.started){
        const limited = limitQuestions(available, state.questionCount);
        state.questions = limited;
        state.stageMeta = limited.map(() => null);
        state.index = 0;
        state.attempt = 0;
        state.sessionId = null;
        clearInputEventHandlers();
        state.inputs = [];
        state.fieldSpecs = [];
        const answerContainer = $('#answer-inputs');
        if(answerContainer){
          answerContainer.innerHTML = '';
        }
        const questionEl = $('#question');
        if(questionEl){
          questionEl.textContent = '';
        }
        if(quizCard) quizCard.style.display = 'none';
        if(loadingCard) loadingCard.style.display = 'none';
        if(errorCard) errorCard.style.display = 'none';
        const btnCheck = $('#btn-check');
        if(btnCheck) btnCheck.disabled = true;
        const btnNext = $('#btn-next');
        if(btnNext) btnNext.disabled = true;
        $('#feedback').textContent = '';
        $('#feedback').className = 'muted';
        setSaveStatus('', 'muted');
        updateStartNote(available.length, limited.length);
        updateStageIndicators(null);
        return;
      }

      const btnCheck = $('#btn-check');
      const btnNext = $('#btn-next');
      if(btnCheck) btnCheck.disabled = true;
      if(btnNext) btnNext.disabled = true;

      state.index = 0;
      state.attempt = 0;
      state.sessionId = null;
      state.questions = [];
      state.stageMeta = [];

      if(!available.length){
        if(quizCard) quizCard.style.display = 'none';
        if(loadingCard){
          loadingCard.style.display = '';
          loadingCard.textContent = '選択した難易度の問題が見つかりませんでした。';
        }
        updateStageIndicators(null);
        return;
      }

      const requested = Number(state.questionCount);
      const desiredCount = Number.isFinite(requested)
        ? Math.min(available.length, Math.max(MIN_QUESTION_COUNT, Math.min(MAX_QUESTION_COUNT, Math.floor(requested))))
        : Math.min(available.length, MIN_QUESTION_COUNT);

      if(quizCard) quizCard.style.display = 'none';
      if(errorCard) errorCard.style.display = 'none';
      if(loadingCard){
        loadingCard.style.display = '';
        loadingCard.textContent = '出題順を準備しています…';
      }

      const currentToken = ++rankingRequestId;

      rankQuestionsForUser(available, state.user, desiredCount)
        .then(result => {
          if(rankingRequestId !== currentToken) return;
          const questions = Array.isArray(result.questions) ? result.questions : [];
          const meta = Array.isArray(result.meta) ? result.meta : [];
          state.questions = questions;
          state.stageMeta = meta;
          state.index = 0;
          state.attempt = 0;
          state.sessionId = createSessionId();
          renderQuestion();
        })
        .catch(err => {
          console.warn('数学のランク計算に失敗しました', err);
          if(rankingRequestId !== currentToken) return;
          const fallback = shuffle(available).slice(0, desiredCount);
          state.questions = fallback;
          state.stageMeta = fallback.map(() => null);
          state.index = 0;
          state.attempt = 0;
          state.sessionId = createSessionId();
          renderQuestion();
        });
    }

    function setDifficulty(level){
      state.difficulty = normalizeDifficulty(level);
      updateQuestionPool();
    }

    function setQuestionCount(value){
      state.questionCount = normalizeQuestionCount(value);
      updateQuestionPool();
    }

    function renderQuestion(){
      if(!state.questions.length){
        if(quizCard) quizCard.style.display = 'none';
        if(loadingCard){
          loadingCard.style.display = '';
          loadingCard.textContent = '選択した難易度の問題が見つかりませんでした。';
        }
        const btnCheck = $('#btn-check');
        const btnNext = $('#btn-next');
        if(btnCheck) btnCheck.disabled = true;
        if(btnNext) btnNext.disabled = true;
        updateStageIndicators(null);
        return;
      }
      const q = state.questions[state.index];
      if(loadingCard) loadingCard.style.display = 'none';
      if(quizCard) quizCard.style.display = '';
      if(errorCard) errorCard.style.display = 'none';
      updateDifficultyBadge(q && q.difficulty ? q.difficulty : state.difficulty);
      const questionEl = $('#question');
      if(questionEl){
        questionEl.textContent = q.prompt || q.question || '';
      }
      const stageMeta = Array.isArray(state.stageMeta) ? state.stageMeta[state.index] : null;
      updateStageIndicators(stageMeta);
      buildInputs(q);
      state.inputs.forEach(input => { input.value = ''; });
      $('#feedback').textContent = '';
      $('#feedback').className = 'muted';
      setSaveStatus('', 'muted');
      state.graded = false;
      const btnCheck = $('#btn-check');
      if(btnCheck) btnCheck.disabled = false;
      const btnNext = $('#btn-next');
      if(btnNext){
        btnNext.disabled = true;
        const isLastQuestion = state.questions.length && state.index >= state.questions.length - 1;
        btnNext.textContent = isLastQuestion ? 'トップに戻る' : '次の問題 ▶';
      }
      if(quizCard) quizCard.style.display = '';
      if(loadingCard) loadingCard.style.display = 'none';
      if(state.inputs[0]){
        state.inputs[0].focus();
      }
    }

    function sanitizeExplain(raw){
      if(!raw) return '';
      let text = String(raw).trim();
      text = text.replace(/(?:答え|正解)[:：]?.*$/u, '').trim();
      return text;
    }

    function buildExplain(q){
      if(!q || !q.explain) return '';
      const hint = sanitizeExplain(q.explain);
      if(!hint) return '';
      return `<div class="muted" style="margin-top:8px">解説: ${hint}</div>`;
    }

    function checkAnswer(){
      if(state.graded) return;
      const q = state.questions[state.index];
      if(!q){
        $('#feedback').className = 'ng';
        $('#feedback').textContent = '問題が読み込めませんでした。';
        return;
      }
      const userValues = getUserValues();
      const fieldSpecs = state.fieldSpecs;
      const answers = getAnswerList(q);
      if(!answers.length){
        $('#feedback').className = 'muted';
        $('#feedback').textContent = '正解が登録されていません。';
        state.graded = true;
        const btnNext = $('#btn-next');
        if(btnNext) btnNext.disabled = false;
        return;
      }
      const isCorrect = answers.some(candidate => matchesAnswer(candidate, userValues, fieldSpecs));
      state.graded = true;
      const btnNext = $('#btn-next');
      if(btnNext) btnNext.disabled = false;
      const explain = buildExplain(q);
      state.attempt += 1;
      sendMathResult(q, isCorrect, userValues, fieldSpecs);
      if(isCorrect){
        $('#feedback').className = 'ok';
        $('#feedback').innerHTML = `✅ 正解です！${explain}`;
      } else {
        $('#feedback').className = 'ng';
        const retryMessage = '❌ 不正解。もう一度チャレンジしてみましょう。';
        $('#feedback').innerHTML = explain ? `${retryMessage}${explain}` : retryMessage;
      }
    }

    function nextQuestion(){
      if(!state.graded){
        checkAnswer();
        if(!state.graded) return;
      }
      const totalQuestions = state.questions.length;
      if(!totalQuestions){
        showSetupView();
        return;
      }
      const isLastQuestion = state.index >= totalQuestions - 1;
      if(isLastQuestion){
        state.sessionId = null;
        state.attempt = 0;
        showSetupView();
        if(startNote){
          startNote.textContent = '選択した条件の問題をすべて解き終えました。演習を再開するには「演習を開始」を押してください。';
        }
        return;
      }
      state.index += 1;
      renderQuestion();
    }

    if(startButton){
      startButton.addEventListener('click', ev => {
        ev.preventDefault();
        if(startButton.disabled) return;
        if(!state.allQuestions.length) return;
        if(learnerInput){
          setUser(learnerInput.value, { remember: true });
        } else {
          setUser(state.user, { remember: false });
        }
        state.started = true;
        if(setupCard) setupCard.style.display = 'none';
        setDifficulty(state.difficulty);
        if(startNote){
          startNote.textContent = '出題条件を変更するには「出題条件を変更」を押してください。';
        }
      });
    }

    if(changeSettingsButton){
      changeSettingsButton.addEventListener('click', ev => {
        ev.preventDefault();
        showSetupView();
      });
    }

    $('#btn-check').addEventListener('click', checkAnswer);
    $('#btn-next').addEventListener('click', nextQuestion);
    function createSessionId(){
      return `math-${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`;
    }

    function toAnswerPayload(question, userValues, fieldSpecs, isCorrect){
      const payload = {
        id: question && question.id ? String(question.id) : null,
        correct: !!isCorrect,
        prompt: question && (question.prompt || question.question) ? String(question.prompt || question.question) : '',
      };
      payload.difficulty = normalizeDifficulty(question && question.difficulty);
      if(fieldSpecs && fieldSpecs.length){
        const answerMap = {};
        fieldSpecs.forEach((field, idx) => {
          const key = field && field.key ? String(field.key) : `field${idx}`;
          answerMap[key] = userValues[idx] || '';
        });
        payload.response = answerMap;
      } else {
        payload.response = Array.isArray(userValues) && userValues.length === 1 ? userValues[0] : userValues;
      }
      const answers = getAnswerList(question);
      if(answers && answers.length){
        payload.acceptedAnswers = answers;
      }
      return payload;
    }

    function sendMathResult(question, isCorrect, userValues, fieldSpecs){
      if(!question) return;
      if(!state.sessionId){
        state.sessionId = createSessionId();
      }
      const questionDifficulty = normalizeDifficulty(question && question.difficulty);
      const effectiveUser = getEffectiveUserName(state.user);
      const record = {
        subject: SUBJECT,
        user: effectiveUser,
        mode: 'math-drill',
        sessionId: state.sessionId,
        attempt: state.attempt,
        questionIndex: state.index,
        difficulty: questionDifficulty,
        total: 1,
        correct: isCorrect ? 1 : 0,
        wrong: isCorrect ? 0 : 1,
        endedAt: new Date().toISOString(),
        answered: [toAnswerPayload(question, userValues, fieldSpecs, isCorrect)]
      };
      record.answered[0].difficulty = questionDifficulty;
      setSaveStatus('採点結果を送信しています…', 'muted');
      fetch(RESULT_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(record)
      })
        .then(() => {
          setSaveStatus('採点結果を記録しました。', 'success');
        })
        .catch(err => {
          console.warn('数学の結果送信に失敗しました', err);
          setSaveStatus('結果の送信に失敗しました。時間をおいて再度お試しください。', 'error');
        });
    }

    fetch(QUESTIONS_URL, { cache: 'no-store' })
      .then(res => {
        if(!res.ok) throw new Error(`fetch ${QUESTIONS_URL} ${res.status}`);
        return res.json();
      })
      .then(data => {
        const loaded = Array.isArray(data.questions) ? data.questions : [];
        state.allQuestions = loaded.map(q => ({ ...q, difficulty: normalizeDifficulty(q && q.difficulty) }));
        if(!state.allQuestions.length){
          if(loadingCard){
            loadingCard.style.display = '';
            loadingCard.textContent = '問題が見つかりませんでした。';
          }
          if(startButton){
            startButton.disabled = true;
            startButton.textContent = '演習を開始';
          }
          if(startNote){
            startNote.textContent = '問題が見つからないため演習を開始できません。';
          }
          return;
        }
        if(loadingCard) loadingCard.style.display = 'none';
        if(startButton){
          startButton.disabled = false;
          startButton.textContent = '演習を開始';
        }
        if(startNote){
          startNote.textContent = '開始を押すと問題が表示されます。';
        }
        if(setupCard) setupCard.style.display = '';
        setDifficulty(state.difficulty);
      })
      .catch(err => {
        if(loadingCard) loadingCard.style.display = 'none';
        if(quizCard) quizCard.style.display = 'none';
        if(errorCard){
          errorCard.style.display = '';
          errorCard.textContent = `問題の読み込みに失敗しました: ${err.message}`;
        }
        if(startButton){
          startButton.disabled = true;
          startButton.textContent = '演習を開始';
        }
        if(startNote){
          startNote.textContent = '問題の読み込みに失敗しました。時間をおいて再度お試しください。';
        }
        if(setupCard) setupCard.style.display = '';
      });
</script>
</body>
</html>
