<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>è‹±èªã‚¯ã‚¤ã‚ºï½œä¸¦ã¹æ›¿ãˆï¼‹å˜èªé¸æŠï¼‹æ›¸ãæ›ãˆ</title>
  <style>
    :root{ --bg:#0f172a; --card:#111827; --muted:#94a3b8; --text:#e5e7eb; --border:#1f2937; --accent:#3b82f6; --warn:#ef4444 }
    *{ box-sizing:border-box }
    body{ margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif; -webkit-text-size-adjust:100% }
    header{ position:sticky; top:0; background:rgba(17,24,39,.9); backdrop-filter:saturate(150%) blur(6px); border-bottom:1px solid var(--border); z-index:10 }
    .container{ max-width:980px; margin:0 auto; padding:16px }
    .card{ background:var(--card); border:1px solid var(--border); border-radius:14px; padding:16px; margin:16px 0 }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
    .pill{ display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius:999px; border:1px solid #334155; background:#0b1220; color:#cbd5e1; font-size:12px }
    input,select{ background:#0b1220; color:#e5e7eb; border:1px solid #334155; border-radius:12px; padding:8px 10px }
    button{ border:1px solid #334155; background:#1f2937; color:#e5e7eb; border-radius:12px; padding:10px 14px; font-weight:700; cursor:pointer }
    button.primary{ background:var(--accent); border-color:var(--accent); color:white }
    button.warn{ background:var(--warn); border-color:var(--warn); color:white }
    button:disabled{ opacity:.5; cursor:not-allowed }
    .muted{ color:var(--muted) }
    .right{ margin-left:auto }
    .kbd{ font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; border:1px solid #334155; background:#0b1220; border-radius:6px; padding:2px 6px; color:#cbd5e1 }
    .target{ min-height:52px; padding:8px; background:#0b1220; border:2px dashed var(--accent); border-radius:12px; display:flex; gap:8px; flex-wrap:wrap }
    .bank{ display:flex; flex-wrap:wrap; gap:8px }
    .choice-grid{ display:grid; gap:10px; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); margin-top:10px }
    .choice-option{ border:1px solid #334155; background:#0b1220; border-radius:12px; padding:12px; text-align:left; cursor:pointer; transition:.15s; min-height:52px; font-size:15px; line-height:1.4 }
    .choice-option:hover{ transform:translateY(-1px) }
    .choice-option.selected{ border-color:var(--accent); background:rgba(59,130,246,.2); box-shadow:0 0 0 1px var(--accent) inset }
    .choice-option:focus-visible{ outline:2px solid var(--accent); outline-offset:2px }
    .chip{ background:#0b1220; border:1px solid #334155; border-radius:999px; padding:8px 12px; cursor:pointer; transition:.15s; user-select:none; min-height:44px }
    .chip:hover{ transform:translateY(-1px) }
    .chip.used{ opacity:.45; cursor:default }
    .ok{ color:#22c55e } .ng{ color:#ef4444 }
    .field{ display:flex; gap:8px; align-items:center }
    .input{ background:#0b1220; color:#e5e7eb; border:1px solid #334155; border-radius:10px; padding:10px 12px; min-width:240px }

    /* iOS Safari ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã®è‡ªå‹•ã‚ºãƒ¼ãƒ æŠ‘æ­¢ï¼š16pxä»¥ä¸Šã«çµ±ä¸€ */
    @supports (-webkit-touch-callout: none) {
      input, select, textarea { font-size:16px; line-height:1.2; }
      .input { font-size:16px; }
      #count { font-size:16px; }
    }
    input, select, textarea { min-height:44px; }

    /* --- ãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ– & æ“ä½œãƒœã‚¿ãƒ³ã®æŠ¼ã—ã‚„ã™ã•æ”¹å–„ --- */
    :root{ --tap:44px }
    body{ touch-action:manipulation }
    #rewrite-input{ width:100%; min-height:72px; resize:vertical; }
    #target,#bank{ gap:10px }
    #bank{ max-height:40vh; overflow:auto; padding-bottom:6px }

    /* æ“ä½œãƒœã‚¿ãƒ³é…ç½®ï¼šè§£ç­”ç¢ºèªã‚’æœ€å„ªå…ˆãƒ»å¤§ãã */
    #quiz .actions{ display:flex; flex-wrap:wrap; gap:10px; }
    #btn-check{ order:1; flex:1 1 100%; padding:14px 18px; font-size:18px; }
    #btn-next{ order:2; flex:1 1 48%; }
    #btn-undo, #btn-clear, #btn-speak{ order:3; flex:1 1 30%; min-width:120px }
    @media (min-width:820px){
      #btn-check{ flex-basis:60%; font-size:16px; }
      #btn-next{ flex-basis:auto; }
    }
  </style>
</head>
<body>
  <header>
    <div class="container row">
      <div>
        <h2 style="margin:0">è‹±èªã‚¯ã‚¤ã‚º <span class="muted">ï¼ˆä¸¦ã¹æ›¿ãˆï¼‹å˜èªé¸æŠï¼‹æ›¸ãæ›ãˆï¼‰</span></h2>
        <div class="muted" style="font-size:12px">å¤–éƒ¨JSONï¼å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰ï¼ä¸€å•ä¸€æ¡ç‚¹ï¼å®Œäº†æ™‚ã¯æœ€å°ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚’ã‚µãƒ¼ãƒä¿å­˜ã€‚</div>
      </div>
      <div class="right pill" id="user-pill">ğŸ‘¤ ã‚²ã‚¹ãƒˆ</div>
    </div>
  </header>

  <main class="container">
    <!-- è¨­å®š -->
    <section class="card" id="setup">
      <div class="row">
        <label class="row" style="gap:6px"><span class="muted">å­¦ç¿’è€…å</span><input id="learner" type="text" placeholder="taro" autocomplete="off" autocapitalize="off" list="user-suggestions" /></label><datalist id="user-suggestions"></datalist>
        <label class="row" style="gap:6px"><span class="muted">1ã‚»ãƒƒãƒˆã®å‡ºé¡Œæ•°</span><input id="count" type="number" min="3" max="20" value="7" style="width:80px"/></label>
        <label class="row" style="gap:6px"><span class="muted">å‡ºé¡Œã‚¿ã‚¤ãƒ—</span>
          <select id="qtype">
            <option value="reorder">ä¸¦ã¹æ›¿ãˆï¼ˆæ–‡æ³•ï¼‰</option>
            <option value="rewrite">æ›¸ãæ›ãˆï¼ˆæŒ‡å®šã®å½¢ã«ï¼‰</option>
            <option value="vocab-choice">å˜èªï¼ˆè‹±èªâ†’æ„å‘³ é¸æŠå¼ï¼‰</option>
          </select>
        </label>
        <label class="row" style="gap:6px"><span class="muted">ãƒ¦ãƒ‹ãƒƒãƒˆ</span>
          <select id="unit-filter">
            <option value="">å…¨ãƒ¦ãƒ‹ãƒƒãƒˆ</option>
          </select>
        </label>
        <button class="primary" id="btn-start">â–¶ å­¦ç¿’ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        <button id="btn-weak" title="éå»7æ—¥ã®æ­£ç­”ç‡ãŒä½ã„å•é¡Œ">ğŸ¯ å¼±ç‚¹å¯¾ç­–ï¼ˆéå»7æ—¥ï¼‰</button>
      </div>
      <div class="muted" style="margin-top:8px">
        ä¸¦ã¹æ›¿ãˆ: <span class="kbd">1-9</span> ã§é¸æŠã€<span class="kbd">Backspace</span> ã§æˆ»ã™ã€<span class="kbd">Enter</span> ã§æ¡ç‚¹/æ¬¡ã¸ã€‚<br>
        æ›¸ãæ›ãˆ: æŒ‡ç¤ºã«å¾“ã£ã¦è‹±æ–‡ã‚’å…¥åŠ›ï¼ˆå¥èª­ç‚¹ã‚‚å¿˜ã‚Œãšã«ï¼‰ã€‚<br>
        å˜èªï¼ˆé¸æŠå¼ï¼‰: è¡¨ç¤ºã•ã‚Œã‚‹è‹±å˜èªã«åˆã†æ—¥æœ¬èªã®æ„å‘³ã‚’é¸æŠã€‚
      </div>
    </section>

    <!-- ã‚¯ã‚¤ã‚ºï¼ˆå…±é€šãƒ˜ãƒƒãƒ€ï¼‰ -->
    <section class="card" id="quiz" style="display:none">
      <div class="row">
          <span class="pill" id="status">Q 1/7</span>
          <span class="pill">æ­£è§£: <b id="stat-correct">0</b></span>
          <span class="pill">èª¤ç­”: <b id="stat-wrong">0</b></span>
          <span class="pill" id="stat-streak">é€£ç¶šæ­£è§£: --</span>
          <span class="pill" id="stat-accuracy">æ­£è§£ç‡: --</span>
          <span class="pill" id="stat-stage">ã‚¹ãƒ†ãƒ¼ã‚¸: --</span>
          <span class="pill" id="stat-bucket">ãƒã‚±ãƒƒãƒˆ: --</span>
          <span class="pill right" id="timer">â± 00:00</span>
      </div>
      <div id="prompt" class="muted">ï¼ˆæ—¥æœ¬èªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆï¼‰</div>

      <!-- ä¸¦ã¹æ›¿ãˆUI -->
      <div id="ui-reorder">
        <div id="target" class="target" aria-label="ç­”ãˆã®ã‚¨ãƒªã‚¢"></div>
        <div id="bank" class="bank" aria-label="å˜èªã®ã‚¨ãƒªã‚¢"></div>
      </div>

      <!-- å˜èªé¸æŠUI -->
      <div id="ui-vocab-choice" style="display:none; margin-top:10px">
        <div class="muted" id="vocab-choice-tip" style="margin-bottom:6px"></div>
        <div id="vocab-choice-options" class="choice-grid" role="radiogroup" aria-label="æ—¥æœ¬èªã®æ„å‘³ã‚’é¸æŠ"></div>
      </div>

      <!-- æ›¸ãæ›ãˆUI -->
      <div id="ui-rewrite" style="display:none; margin-top:10px">
        <div class="muted" id="rewrite-extra" style="margin-bottom:6px"></div>
        <div class="field">
          <textarea id="rewrite-input" class="input" placeholder="æŒ‡ç¤ºã«åˆã‚ã›ã¦è‹±æ–‡ã‚’æ›¸ãæ›ãˆã¦ãã ã•ã„" autocapitalize="off" autocorrect="off" spellcheck="false"></textarea>
          <button id="btn-clear-rewrite">ğŸ§¹ ã‚¯ãƒªã‚¢</button>
        </div>
        <div class="muted" id="rewrite-tip" style="margin-top:6px"></div>
      </div>

      <div class="row actions" style="margin-top:10px">
        <button class="primary" id="btn-check">ç­”ãˆåˆã‚ã› <span class="kbd">Enter</span></button>
        <button id="btn-next" disabled>æ¬¡ã®å•é¡Œ â–¶</button>
        <button id="btn-undo">â†© ã²ã¨ã¤æˆ»ã™</button>
        <button id="btn-clear">ğŸ§¹ ã‚¯ãƒªã‚¢</button>
        <button id="btn-speak">ğŸ”Š æ­£è§£æ–‡/å˜èª</button>
        <button id="btn-hint">ğŸ’¡ ãƒ’ãƒ³ãƒˆ</button>
      </div>
      <div id="explain" class="muted" style="min-height:1.6em"></div>
    </section>

    <!-- ã‚»ãƒƒãƒˆçµ‚äº† -->
    <section class="card" id="finished" style="display:none">
      <h3 style="margin:0 0 8px">ã‚»ãƒƒãƒˆå®Œäº†ï¼</h3>
      <p id="summary" class="muted"></p>
      <p id="save-status" class="muted">çµæœé€ä¿¡: å¾…æ©Ÿä¸­â€¦</p>
      <div class="row">
        <button class="primary" id="btn-review-thisset" disabled>â—ã“ã®ã‚»ãƒƒãƒˆã®ã¾ã¡ãŒã„ã§å¾©ç¿’</button>
        <button class="primary" id="btn-nextset">â–¶ æ¬¡ã®å•é¡Œç¾¤ï¼ˆæ¬¡ã‚»ãƒƒãƒˆï¼‰</button>
        <button id="btn-dashboard">ğŸ“Š æˆç¸¾ã‚’è¦‹ã‚‹</button>
        <button class="warn right" id="btn-to-setup">è¨­å®šã«æˆ»ã‚‹</button>
      </div>
    </section>
  </main>

  <script src="fallback_extras.js"></script>
  <script src="stage_priority.js"></script>
  <script>
    /********** è¨­å®š **********/
    const SUBJECT = 'english';
    const QUESTIONS_URL = `/data/${SUBJECT}/questions.json`; // Flaskã§é…ä¿¡
    const DEFAULT_ENDPOINT = "/api/results";
    const LEVEL_ORDER = ['Lv1','Lv2','Lv3'];
    const DEFAULT_LEVEL = LEVEL_ORDER[0];

    // è¨­å®šã®è¨˜æ†¶ç”¨ã‚­ãƒ¼
    const REMEMBER_USER_KEY = 'quiz:lastUser';
    const REMEMBER_QTYPE_KEY = 'quiz:lastQType';
    const REMEMBER_UNIT_KEY = 'quiz:lastUnitFilter';
    const USER_SUGGEST_KEY = 'quiz:userList';

    /********** å•é¡Œãƒ­ãƒ¼ãƒ‰ **********/
    let BANK_REORDER = [];
    let BANK_VOCAB_CHOICE = [];
    let BANK_REWRITE = [];

    const toAnswerList = (value)=>{
      if(Array.isArray(value)){
        return value
          .map(v=>typeof v==='string'? v.trim(): '')
          .filter(v=>v);
      }
      if(typeof value==='string'){
        const trimmed = value.trim();
        return trimmed? [trimmed] : [];
      }
      return [];
    };

    const collectAnswerSet = (item)=>{
      const primary = toAnswerList(item.en);
      const extras = [];
      [item.accept, item.accepts, item.answers, item.alternates, item.variants]
        .forEach(src=>{ toAnswerList(src).forEach(ans=>extras.push(ans)); });
      const merged = [...primary, ...extras];
      if(!merged.length && typeof item.en==='string'){
        const fallback = item.en.trim();
        if(fallback) merged.push(fallback);
      }
      const unique = [];
      merged.forEach(ans=>{ if(!unique.includes(ans)) unique.push(ans); });
      return unique;
    };

    const caseAware = (match, replacement)=>{
      if(!match) return replacement;
      if(match === match.toUpperCase()) return replacement.toUpperCase();
      if(match[0] === match[0].toUpperCase()){
        return replacement.charAt(0).toUpperCase() + replacement.slice(1);
      }
      return replacement.toLowerCase();
    };

    const replaceAmNot = text=>{
      const regex = /\b(I)\s+am not\b/gi;
      let changed = false;
      const result = text.replace(regex, (match)=>{
        changed = true;
        if(match === match.toUpperCase()) return "I'M NOT";
        const base = match[0]===match[0].toUpperCase()? "I'm not" : "i'm not";
        return caseAware(match, base);
      });
      return changed && result!==text ? result : null;
    };

    const replaceSimple = (text, pattern, contracted)=>{
      let changed = false;
      const result = text.replace(pattern, match=>{
        changed = true;
        return caseAware(match, contracted);
      });
      return changed && result!==text ? result : null;
    };

    const expandRewriteVariants = list=>{
      const queue = [];
      const seen = new Set();
      const push = value=>{
        if(typeof value !== 'string') return;
        const trimmed = value.trim();
        if(!trimmed || seen.has(trimmed)) return;
        seen.add(trimmed);
        queue.push(trimmed);
      };
      list.forEach(push);
      const variants = [];
      const replacers = [
        text=>replaceAmNot(text),
        text=>replaceSimple(text, /\bare not\b/gi, "aren't"),
        text=>replaceSimple(text, /\bis not\b/gi, "isn't"),
        text=>replaceSimple(text, /\bwas not\b/gi, "wasn't"),
        text=>replaceSimple(text, /\bwere not\b/gi, "weren't"),
        text=>replaceSimple(text, /\bdo not\b/gi, "don't"),
        text=>replaceSimple(text, /\bdoes not\b/gi, "doesn't"),
        text=>replaceSimple(text, /\bdid not\b/gi, "didn't"),
        text=>replaceSimple(text, /\bhas not\b/gi, "hasn't"),
        text=>replaceSimple(text, /\bhave not\b/gi, "haven't"),
        text=>replaceSimple(text, /\bhad not\b/gi, "hadn't"),
        text=>replaceSimple(text, /\bwill not\b/gi, "won't"),
        text=>replaceSimple(text, /\bwould not\b/gi, "wouldn't"),
        text=>replaceSimple(text, /\bshould not\b/gi, "shouldn't"),
        text=>replaceSimple(text, /\bmust not\b/gi, "mustn't"),
        text=>replaceSimple(text, /\bneed not\b/gi, "needn't"),
        text=>replaceSimple(text, /\bcould not\b/gi, "couldn't"),
        text=>replaceSimple(text, /\bcannot\b/gi, "can't"),
        text=>replaceSimple(text, /\bcan not\b/gi, "can't"),
        text=>replaceSimple(text, /\bmight not\b/gi, "mightn't")
      ];
      while(queue.length){
        const current = queue.shift();
        variants.push(current);
        replacers.forEach(fn=>{
          const next = fn(current);
          if(next){ push(next); }
        });
      }
      return variants;
    };

    const normalizeLevel = (value)=>{
      const str = (value==null ? '' : String(value)).trim();
      if(LEVEL_ORDER.includes(str)) return str;
      const match = str.match(/([1-3])/);
      if(match){
        const candidate = `Lv${match[1]}`;
        if(LEVEL_ORDER.includes(candidate)) return candidate;
      }
      return DEFAULT_LEVEL;
    };

    const levelIndex = (value)=>{
      const lvl = normalizeLevel(value);
      const idx = LEVEL_ORDER.indexOf(lvl);
      return idx === -1 ? LEVEL_ORDER.length : idx;
    };

    const questionKey = (question)=>{
      if(!question) return '';
      if(question.id != null) return `id:${question.id}`;
      const type = question.type || '';
      const en = question.en || '';
      const jp = question.jp || '';
      return `${type}:${en}__${jp}`;
    };

    const buildQuestion = (item, type)=>{
      let answers = collectAnswerSet(item);
      const primary = answers[0] || (typeof item.en==='string'? item.en.trim(): '');
      if(type==='rewrite'){
        answers = expandRewriteVariants(answers);
      }
      const base = {
        type,
        id: item.id||null,
        unit: item.unit||null,
        jp: item.jp,
        en: primary,
        answers,
        tip: item.tip||'',
        explain: item.explain||'',
        level: normalizeLevel(item.level)
      };
      if(type==='reorder'){
        base.chunks = item.chunks;
        base.wrong = item.wrong||[];
      } else if(type==='vocab-choice'){
        base.pos = item.pos||'';
        if(Array.isArray(item.choices)){
          const normalized = [];
          item.choices.forEach(choice=>{
            if(choice==null) return;
            if(typeof choice === 'string'){
              const text = choice.trim();
              if(!text) return;
              normalized.push({ text, correct: false });
              return;
            }
            if(typeof choice === 'object'){
              const rawText = typeof choice.text === 'string'
                ? choice.text
                : (typeof choice.value === 'string' ? choice.value : '');
              const text = rawText.trim();
              if(!text) return;
              normalized.push({ text, correct: choice.correct === true });
            }
          });
          if(normalized.length){
            base.choices = normalized;
          }
        }
      } else if(type==='rewrite'){
        base.source = item.source || '';
        base.task = item.task || '';
        base.note = item.note || '';
      }
      return base;
    };
    async function ensureQuestions(){
      if (BANK_REORDER.length || BANK_VOCAB_CHOICE.length || BANK_REWRITE.length){ renderUnitFilterOptions(); return; }
      const res = await fetch(QUESTIONS_URL, { cache: "no-store" });
      if (!res.ok) throw new Error("è³ªå•ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—: " + res.status);
      const data = await res.json();
      // äº’æ›: æ—§å½¢å¼ questions ã¯ä¸¦ã¹æ›¿ãˆæ‰±ã„
      const rawVocabChoice = Array.isArray(data.vocabChoice)
        ? data.vocabChoice
        : Array.isArray(data.vocab)
          ? data.vocab.filter(item=>Array.isArray(item.choices) && item.choices.length>0)
          : [];
      BANK_REORDER = (data.questions||data.reorder||[]).map(q=>buildQuestion(q, 'reorder'));
      BANK_VOCAB_CHOICE = rawVocabChoice.map(v=>buildQuestion(v, 'vocab-choice'));
      BANK_REWRITE = (data.rewrite||[]).map(w=>buildQuestion(w, 'rewrite'));
      renderUnitFilterOptions();
    }

    /********** çŠ¶æ…‹ **********/
    const state = {
      user:'guest', endpoint: DEFAULT_ENDPOINT,
      qType:'reorder',
      unitFilter:'',
      levelMax: DEFAULT_LEVEL,
      totalPerSet:7, order:[], setIndex:0,
      qIndex:0, correct:0, wrong:0,
      startedAt:null, seconds:0, timerId:null,
      answered:[],   // ã‚µãƒ¼ãƒé€ä¿¡ç”¨ï¼ˆé€šå¸¸ãƒ¢ãƒ¼ãƒ‰ï¼‰
      reviewed:[],   // ã‚µãƒ¼ãƒé€ä¿¡ç”¨ï¼ˆå¾©ç¿’ãƒ¢ãƒ¼ãƒ‰ï¼‰
      graded:false,  // ä¸€å•ä¸€æ¡ç‚¹
      mode:'normal',
      reviewStrategy:'all', // 'all' | 'recent'
      weakWindowDays:7,      // éå»â—¯æ—¥ã‚’å¯¾è±¡
      missedSetDeck: [],   // ã“ã®ã‚»ãƒƒãƒˆã§é–“é•ãˆãŸå•é¡Œã®ãƒ‡ãƒƒã‚­
      choiceSelection: null,
      fallbackExtras: [],  // ãƒ¬ãƒ™ãƒ«ä¸è¶³ã‚’è£œã†è¿½åŠ å•é¡Œï¼ˆã“ã®ã‚»ãƒƒãƒˆé™å®šï¼‰
      fallbackStageOverrides: new Map(), // è£œå……å•é¡Œã®ã‚¹ãƒ†ãƒ¼ã‚¸ä¸Šæ›¸ãï¼ˆå•é¡Œã‚­ãƒ¼ -> ã‚¹ãƒ†ãƒ¼ã‚¸ï¼‰
    };

    const $ = s=>document.querySelector(s);
    const $$ = s=>Array.from(document.querySelectorAll(s));

    const typedInputElement = ()=> state.qType==='rewrite' ? $('#rewrite-input') : null;

    /********** ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ **********/
    const fmtTime = s=>{ const m=String(Math.floor(s/60)).padStart(2,'0'); const r=String(s%60).padStart(2,'0'); return `${m}:${r}` };
    const shuffle = arr=>arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);
    const NBSP = String.fromCharCode(160);
    const normalizeDigits = s=> (s==null ? '' : String(s).replace(/[â€˜â€™â€šâ€›â€¹â€º`Â´]/g,"'").replace(/[â€œâ€â€â€ŸÂ«Â»]/g,'"').replace(/[ï¼-ï¼™]/g, ch=> String.fromCharCode(ch.charCodeAt(0)-0xFEE0)));
    const normalizeSpaces = s=> normalizeDigits(s).replace(new RegExp(`[${NBSP}\\s]+`,'g'),' ').trim();
    const normalizeEndPunc = (s, keep=false)=> keep ? s.replace(/\s+([.,!?])/g, "$1") : s.replace(/\s*[.,!?]$/,'');
    const normalizeWord = s=> normalizeSpaces(s).toLowerCase();
    const normalizeUnit = u=> (u===null || u===undefined ? '' : String(u).trim());
    const normalizePos = pos=> {
      if(pos===null || pos===undefined) return '';
      return String(pos).trim().toLowerCase();
    };
    const HARD_STREAK = 2;
    const MIN_VOCAB_CHOICE_OPTIONS = 3;
    const nowISO = ()=> new Date().toISOString();

    async function postJSON(url, data, timeoutMs=6000){
      const ctrl = new AbortController();
      const t = setTimeout(()=>ctrl.abort(), timeoutMs);
      try{
        const res = await fetch(url,{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(data), signal: ctrl.signal});
        clearTimeout(t);
        return {ok: res.ok, status: res.status};
      }catch(e){ clearTimeout(t); return {ok:false, error:String(e)}; }
    }

    async function startSetCustom(customDeck){
      try{ await ensureQuestions(); }catch(e){ alert(e.message||e); return; }
      if(!customDeck || !customDeck.length){ alert('ã“ã®ã‚»ãƒƒãƒˆã®é–“é•ã„ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚'); return; }

      // ã‚»ãƒƒãƒˆåˆæœŸåŒ–
      state.qIndex=0; state.correct=0; state.wrong=0; state.answered=[]; state.reviewed=[]; state.graded=false; state.choiceSelection=null;
      $('#stat-correct').textContent='0'; $('#stat-wrong').textContent='0';

      // ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ‡ãƒƒã‚­ã«æµã—è¾¼ã‚€ï¼ˆæ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯æµç”¨ï¼‰
      window.__REVIEW_DECK__ = customDeck.map(q=>({ ...q }));
      state.order = await createOrderEntriesFromIndexes([...window.__REVIEW_DECK__.keys()], window.__REVIEW_DECK__);
      state.mode = 'review';
      // è¡¨ç¤ºUIã‚’åˆã‚ã›ã‚‹ï¼ˆä¸¦ã¹æ›¿ãˆ/å˜èªï¼‰
      state.qType = (window.__REVIEW_DECK__[0]?.type) || state.qType;

      show('quiz'); startTimer(); renderQuestion();
    }

    /********** è¨­å®šã®è¨˜æ†¶ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼åãƒ»å‡ºé¡Œã‚¿ã‚¤ãƒ—ï¼‰ **********/
    function populateUserSuggestions(){
      const dl=document.getElementById('user-suggestions'); if(!dl) return;
      const list=JSON.parse(localStorage.getItem(USER_SUGGEST_KEY)||'[]');
      dl.innerHTML='';
      list.forEach(name=>{ const opt=document.createElement('option'); opt.value=name; dl.appendChild(opt); });
    }

    function readRememberedUnitMap(){
      try{
        const raw = localStorage.getItem(REMEMBER_UNIT_KEY);
        if(!raw) return {};
        const data = JSON.parse(raw);
        return (data && typeof data === 'object') ? data : {};
      }catch(e){
        return {};
      }
    }
    function writeRememberedUnitMap(map){
      try{
        localStorage.setItem(REMEMBER_UNIT_KEY, JSON.stringify(map));
      }catch(e){
        // ignore
      }
    }
    function getRememberedUnitFilter(qType){
      const map = readRememberedUnitMap();
      const lookup = map && typeof map === 'object' ? map : {};
      let val = lookup[qType];
      if((val === undefined || val === null) && qType === 'vocab-choice'){
        val = lookup.vocab;
      }
      return (typeof val === 'string') ? val : '';
    }
    function rememberUnitFilter(qType, value){
      const map = readRememberedUnitMap();
      const v = (value || '').trim();
      if(qType === 'vocab-choice'){
        delete map.vocab;
      }
      if(v){ map[qType] = v; }
      else { delete map[qType]; }
      writeRememberedUnitMap(map);
    }

    function stageFCacheKey(){
      const user = (state.user || '').trim() || 'guest';
      return `${user}::${SUBJECT}`;
    }

    let stageFCache = { key: null, set: new Set(), pending: null, fetched: false };

    function getStageFHistory(){
      const key = stageFCacheKey();
      if(stageFCache.key !== key){
        stageFCache = { key, set: new Set(), pending: null, fetched: false };
      }
      if(!(stageFCache.set instanceof Set)){
        stageFCache.set = new Set();
      }
      return stageFCache.set;
    }

    async function refreshStageFHistory(force=false){
      const key = stageFCacheKey();
      if(stageFCache.key !== key){
        stageFCache = { key, set: new Set(), pending: null, fetched: false };
      }
      if(stageFCache.fetched && !force){
        return stageFCache.set;
      }
      if(stageFCache.pending && !force){
        return stageFCache.pending;
      }
      const trimmedUser = (state.user || '').trim();
      if(!trimmedUser){
        stageFCache.set = new Set();
        stageFCache.fetched = true;
        return stageFCache.set;
      }
      const promise = (async ()=>{
        try{
          const url = `/api/stats/stage-f?user=${encodeURIComponent(trimmedUser)}&subject=${encodeURIComponent(SUBJECT)}`;
          const res = await fetch(url, { cache: 'no-store' });
          if(res.ok){
            const data = await res.json();
            const keys = Array.isArray(data.keys) ? data.keys : [];
            const set = new Set();
            keys.forEach(v=>{ if(typeof v === 'string' && v){ set.add(v); } });
            stageFCache.set = set;
          }else{
            stageFCache.set = new Set();
          }
        }catch(err){
          console.warn('ã‚¹ãƒ†ãƒ¼ã‚¸Få±¥æ­´ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ', err);
          stageFCache.set = new Set();
        }finally{
          stageFCache.pending = null;
          stageFCache.fetched = true;
        }
        return stageFCache.set;
      })();
      stageFCache.pending = promise;
      return promise;
    }

    function rememberStageFKeys(keys){
      if(!Array.isArray(keys) || keys.length === 0) return;
      const set = getStageFHistory();
      keys.forEach(key => {
        if(typeof key === 'string' && key){
          set.add(key);
        }
      });
      stageFCache.fetched = true;
    }

    function clearStageFHistoryCache(){
      stageFCache = { key: null, set: new Set(), pending: null, fetched: false };
    }

    function isEligibleByLevel(question, maxLevelIdx, stageFSet){
      if(!question) return false;
      if(!Number.isFinite(maxLevelIdx)) return true;
      const lvlIdx = levelIndex(question.level);
      if(lvlIdx <= maxLevelIdx) return true;
      if(!(stageFSet instanceof Set)) return false;
      const key = questionKey(question);
      return key ? stageFSet.has(key) : false;
    }

    function renderUnitFilterOptions(){
      const sel = document.getElementById('unit-filter');
      if(!sel) return;
      const maxLevelIdx = levelIndex(state.levelMax);
      const stageFHistory = getStageFHistory();
      const deckArr = deckByType(state.qType).filter(q=> isEligibleByLevel(q, maxLevelIdx, stageFHistory));
      const units = Array.from(new Set(deckArr.map(q=>normalizeUnit(q.unit)).filter(u=>u))).sort((a,b)=>a.localeCompare(b, 'ja', { numeric:true, sensitivity:'base' }));
      sel.innerHTML='';
      const optAll=document.createElement('option'); optAll.value=''; optAll.textContent='å…¨ãƒ¦ãƒ‹ãƒƒãƒˆ'; sel.appendChild(optAll);
      units.forEach(u=>{ const opt=document.createElement('option'); opt.value=u; opt.textContent=u; sel.appendChild(opt); });
      if(deckArr.length===0){
        sel.value='';
        sel.disabled=true;
        if(state.unitFilter){
          state.unitFilter='';
          rememberUnitFilter(state.qType, '');
        }
        return;
      }
      sel.disabled=false;
      if(state.unitFilter && !units.includes(state.unitFilter)){
        state.unitFilter='';
        rememberUnitFilter(state.qType, '');
      }
      sel.value = state.unitFilter || '';
    }
    function loadRememberedSettings(){
      const u=(localStorage.getItem(REMEMBER_USER_KEY)||'').trim();
      if(u){ state.user=u; const inp=document.getElementById('learner'); if(inp) inp.value=u; const pill=document.getElementById('user-pill'); if(pill) pill.textContent=`ğŸ‘¤ ${u}`; }
      const qtRaw=(localStorage.getItem(REMEMBER_QTYPE_KEY)||'').trim();
      const qs=document.getElementById('qtype');
      const qt = qtRaw === 'vocab' ? 'vocab-choice' : qtRaw;
      if(qt){ state.qType=qt; if(qs) qs.value=qt; }
      state.levelMax = DEFAULT_LEVEL;
      state.unitFilter = getRememberedUnitFilter(state.qType);
      const unitSel = document.getElementById('unit-filter');
      if(unitSel){ unitSel.value = state.unitFilter || ''; }
      state.endpoint=DEFAULT_ENDPOINT;
      clearStageFHistoryCache();
      clearWrongQueueCache();
      refreshStageFHistory().catch(()=>{});
      populateUserSuggestions();
    }
    function rememberSettings(){
      if(state.user) localStorage.setItem(REMEMBER_USER_KEY, state.user);
      if(state.qType) localStorage.setItem(REMEMBER_QTYPE_KEY, state.qType);
      rememberUnitFilter(state.qType, state.unitFilter||'');
      const raw=JSON.parse(localStorage.getItem(USER_SUGGEST_KEY)||'[]');
      const list=Array.isArray(raw)? raw.slice(0) : [];
      if(state.user){
        const i=list.indexOf(state.user); if(i!==-1) list.splice(i,1);
        list.unshift(state.user);
        if(list.length>20) list.length=20;
        localStorage.setItem(USER_SUGGEST_KEY, JSON.stringify(list));
      }
      populateUserSuggestions();
    }

    /********** ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ï¼‰ **********/
    async function getHistory(){
      const trimmedUser = (state.user || '').trim();
      if(!trimmedUser){
        return [];
      }
      try{
        const url = `/api/history?user=${encodeURIComponent(trimmedUser)}&subject=${encodeURIComponent(SUBJECT)}`;
        const res = await fetch(url, { cache: 'no-store' });
        if(!res.ok) return [];
        const data = await res.json();
        return Array.isArray(data.history) ? data.history : [];
      }catch(err){
        console.warn('å­¦ç¿’å±¥æ­´ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ', err);
        return [];
      }
    }

    async function pushHistory(session){
      const trimmedUser = (state.user || '').trim();
      if(!trimmedUser || !session || typeof session !== 'object'){ return; }
      try{
        await fetch('/api/history', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user: trimmedUser,
            subject: SUBJECT,
            session,
          }),
        });
      }catch(err){
        console.warn('å­¦ç¿’å±¥æ­´ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ', err);
      }
    }

    function wrongQueueCacheKey(){
      const user = (state.user || '').trim() || 'guest';
      const qType = (state.qType || '').trim() || 'reorder';
      return `${user}::${qType}::${SUBJECT}`;
    }

    let wrongQueueCache = { key: null, list: [], pending: null, fetched: false };

    function ensureWrongQueueCache(){
      const key = wrongQueueCacheKey();
      if(wrongQueueCache.key !== key){
        wrongQueueCache = { key, list: [], pending: null, fetched: false };
      }
      if(!Array.isArray(wrongQueueCache.list)){
        wrongQueueCache.list = [];
      }
      return wrongQueueCache.list;
    }

    function getWrongQueue(){
      return ensureWrongQueueCache();
    }

    async function refreshWrongQueue(force=false){
      const key = wrongQueueCacheKey();
      if(wrongQueueCache.key !== key){
        wrongQueueCache = { key, list: [], pending: null, fetched: false };
      }
      if(wrongQueueCache.fetched && !force){
        return wrongQueueCache.list;
      }
      if(wrongQueueCache.pending && !force){
        return wrongQueueCache.pending;
      }
      const trimmedUser = (state.user || '').trim();
      if(!trimmedUser){
        wrongQueueCache.list = [];
        wrongQueueCache.fetched = true;
        return wrongQueueCache.list;
      }
      const qType = state.qType || '';
      const promise = (async ()=>{
        try{
          const url = `/api/wrong-queue?user=${encodeURIComponent(trimmedUser)}&qType=${encodeURIComponent(qType)}&subject=${encodeURIComponent(SUBJECT)}`;
          const res = await fetch(url, { cache: 'no-store' });
          if(res.ok){
            const data = await res.json();
            const arr = Array.isArray(data.items) ? data.items : [];
            wrongQueueCache.list = arr.filter(item => item && typeof item === 'object').slice(0, 150);
          }else{
            wrongQueueCache.list = [];
          }
        }catch(err){
          console.warn('èª¤ç­”ã‚­ãƒ¥ãƒ¼ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ', err);
          wrongQueueCache.list = [];
        }finally{
          wrongQueueCache.pending = null;
          wrongQueueCache.fetched = true;
        }
        return wrongQueueCache.list;
      })();
      wrongQueueCache.pending = promise;
      return promise;
    }

    async function persistWrongQueue(){
      const trimmedUser = (state.user || '').trim();
      if(!trimmedUser){
        return;
      }
      try{
        await fetch('/api/wrong-queue', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user: trimmedUser,
            qType: state.qType,
            subject: SUBJECT,
            items: getWrongQueue(),
          }),
        });
      }catch(err){
        console.warn('èª¤ç­”ã‚­ãƒ¥ãƒ¼ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ', err);
      }
    }

    function setWrongQueue(list){
      ensureWrongQueueCache();
      wrongQueueCache.list = Array.isArray(list) ? list.slice(0, 150) : [];
      wrongQueueCache.fetched = true;
      persistWrongQueue();
    }

    function clearWrongQueueCache(){
      wrongQueueCache = { key: null, list: [], pending: null, fetched: false };
    }
    function addWrongLocal(item){ const q=getWrongQueue(); const key=item.id?`id:${item.id}`:`${item.en}__${item.jp}`; if(!q.some(x=>x.key===key)){ q.unshift({...item, key}); setWrongQueue(q); } }
    function removeFromWrongIfMatched(rec){ const q=getWrongQueue(); const key=rec.id?`id:${rec.id}`:null; let idx=-1; if(key){ idx=q.findIndex(x=>x.key===key); } if(idx===-1){ idx=q.findIndex(x=>x.en===rec.en && x.jp===rec.jp); } if(idx>-1){ q.splice(idx,1); setWrongQueue(q); } }

    /********** ç”»é¢åˆ‡æ›¿ **********/
    function show(id){ ['setup','quiz','finished'].forEach(sec=>{ const el=$(`#${sec}`); if(!el) return; el.style.display = (sec===id)?'block':'none'; }); }

    /********** ãƒ‡ãƒƒã‚­å–å¾— **********/
    function deckByType(type){
      if(type==='reorder') return BANK_REORDER;
      if(type==='vocab-choice') return BANK_VOCAB_CHOICE;
      if(type==='rewrite') return BANK_REWRITE;
      return [];
    }
    function deck(options){
      const opts = options || {};
      const includeExtras = opts.includeExtras !== false;
      const all = deckByType(state.qType);
      if(state.mode==='review') return all;
      const maxLevelIdx = levelIndex(state.levelMax);
      const stageFHistory = getStageFHistory();
      let filtered = all.filter(q=> isEligibleByLevel(q, maxLevelIdx, stageFHistory));
      const shouldFilterByUnit = state.mode==='normal' || state.mode==='weak';
      const unit = shouldFilterByUnit ? (state.unitFilter || '') : '';
      if(unit){
        filtered = filtered.filter(q=> normalizeUnit(q.unit) === unit);
      }
      if(!includeExtras) return filtered;
      const extras = Array.isArray(state.fallbackExtras) ? state.fallbackExtras : [];
      if(!extras.length) return filtered;
      if(!unit) return filtered.concat(extras);
      const extrasForUnit = extras.filter(q=> normalizeUnit(q.unit) === unit);
      if(!extrasForUnit.length) return filtered;
      return filtered.concat(extrasForUnit);
    }

    const STAGE_PRIORITY = ['A','B','C','D','E'];

    const stagePriorityApi = (typeof window !== 'undefined' && window.__stagePriority)
      ? window.__stagePriority
      : ((typeof globalThis !== 'undefined' && globalThis.__stagePriority)
        ? globalThis.__stagePriority
        : {});
    const shouldPrioritizeStagePromotion = typeof stagePriorityApi.shouldPrioritizeStagePromotion === 'function'
      ? stagePriorityApi.shouldPrioritizeStagePromotion
      : (stage, nextDue, nowMs) => {
          const normalizedStage = typeof stage === 'string' ? stage.trim().toUpperCase() : '';
          if(!STAGE_PRIORITY.includes(normalizedStage) || normalizedStage === 'A'){
            return false;
          }
          if(!(nextDue instanceof Date)){
            return false;
          }
          const effectiveNow = Number.isFinite(nowMs) ? nowMs : Date.now();
          return nextDue.getTime() <= effectiveNow;
        };

    function parseIsoDate(value){
      if(!value) return null;
      const date = new Date(value);
      return Number.isNaN(date.getTime()) ? null : date;
    }

    function normalizeStage(value){
      if(typeof value !== 'string') return 'F';
      const upper = value.trim().toUpperCase();
      if(STAGE_PRIORITY.includes(upper) || upper === 'F') return upper;
      return 'F';
    }

    function willStageUpOnSuccess(stage, nextDue, now){
      const normalizedStage = typeof stage === 'string' ? stage.trim().toUpperCase() : '';
      const effectiveNow = Number.isFinite(now) ? now : Date.now();
      const nextDueValue = nextDue instanceof Date ? nextDue : null;
      return !!shouldPrioritizeStagePromotion(normalizedStage, nextDueValue, effectiveNow);
    }

    async function fetchStatsForEntries(entries, user){
      const trimmedUser = (user || '').trim();
      const ids = entries
        .filter(entry => entry.id)
        .map(entry => entry.id);
      if(!trimmedUser || !ids.length){
        return entries.map(() => null);
      }
      try{
        const res = await fetch('/api/stats/bulk', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user: trimmedUser,
            subject: SUBJECT,
            ids,
          }),
        });
        if(!res.ok){
          throw new Error(`bulk stats failed with ${res.status}`);
        }
        const data = await res.json();
        const list = Array.isArray(data.results) ? data.results : [];
        const map = new Map();
        list.forEach(item => {
          if(item && item.id != null){
            map.set(String(item.id), item);
          }
        });
        return entries.map(entry => {
          if(!entry.id) return null;
          return map.get(entry.id) || null;
        });
      }catch(err){
        console.warn('è‹±èªã®æˆç¸¾ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ', err);
        return entries.map(() => null);
      }
    }

    /********** ã‚»ãƒƒãƒˆæº–å‚™ **********/
    async function buildOrderFromBank(){
      // ã‚¹ãƒ†ãƒ¼ã‚¸Fã®å±¥æ­´ã‚„ä¸è¶³è£œå¡«ã«ã‚ˆã‚‹å„ªå…ˆåˆ¶å¾¡ã«åˆ©ç”¨ã™ã‚‹ã‚­ãƒ¼é›†åˆã€‚
      const blockedFallbackKeys = new Set();
      const MAX_ATTEMPTS = 4;
      let forcedExtraDeficit = 0;
      let forcedStagePromotionAttempted = false;
      let lastOrder = [];

      // ç›´è¿‘ã®ã‚¹ãƒ†ãƒ¼ã‚¸Få‡ºé¡Œã¨é–“é•ã„ã‚­ãƒ¥ãƒ¼ã‚’å–å¾—ã—ã€å„ªå…ˆé †ã‚’æœ€æ–°åŒ–ã€‚
      await refreshStageFHistory();
      await refreshWrongQueue();

      for(let attempt=0; attempt<MAX_ATTEMPTS; attempt++){
        const baseDeck = deck({ includeExtras: false });
        state.fallbackExtras = [];
        state.fallbackStageOverrides = new Map();
        const fallbackStageOverrides = state.fallbackStageOverrides;
        const desired = state.totalPerSet;
        const deckArrBase = baseDeck.slice();
        const baseDeckCount = deckArrBase.length;
        const appendFallbackExtras = (typeof window !== 'undefined'
          && window
          && window.__quizFallbackExtras
          && typeof window.__quizFallbackExtras.appendFallbackExtras === 'function')
            ? window.__quizFallbackExtras.appendFallbackExtras
            : (extrasArr, prioritizedList, othersList, totalNeeded, baseCountValue)=>{
                if(!Array.isArray(extrasArr)) return extrasArr;
                const total = Number.isFinite(totalNeeded) ? Math.max(0, Math.floor(totalNeeded)) : 0;
                if(total === 0) return extrasArr;
                const base = Number.isFinite(baseCountValue)
                  ? Math.min(Math.max(0, Math.floor(baseCountValue)), total)
                  : 0;
                const limit = Math.max(0, total - base);
                if(limit === 0) return extrasArr;
                const pushLimited = (list)=>{
                  if(!Array.isArray(list) || !list.length) return;
                  const remaining = limit - extrasArr.length;
                  if(remaining <= 0) return;
                  extrasArr.push(...list.slice(0, remaining));
                };
                pushLimited(prioritizedList);
                pushLimited(othersList);
                return extrasArr;
              };

        const shouldFilterByUnit = state.mode==='normal' || state.mode==='weak';
        const unitFilter = shouldFilterByUnit ? (state.unitFilter || '') : '';
        const maxLevelIdx = levelIndex(state.levelMax);

        const allDeck = deckByType(state.qType);
        const stageFHistory = getStageFHistory();

        const toKey = (item)=>{
          if(!item) return '';
          try{
            return questionKey(item);
          }catch(_err){
            if(item.id != null) return `id:${item.id}`;
            const en = item.en || '';
            const jp = item.jp || '';
            return `${en}__${jp}`;
          }
        };
        const toLegacyKey = (item)=>{
          if(!item) return '';
          if(item.id != null) return `id:${item.id}`;
          const en = item.en || '';
          const jp = item.jp || '';
          return `${en}__${jp}`;
        };

        const seenKeys = new Set(deckArrBase.map(q=>toKey(q)).filter(Boolean));
        blockedFallbackKeys.forEach(key=>{
          if(key) seenKeys.add(key);
        });

        const baseShortage = Math.max(0, desired - baseDeckCount);
        const extrasLimit = baseShortage + Math.max(0, forcedExtraDeficit);

        if(extrasLimit > 0){
          const wrongSet = new Set();
          (getWrongQueue() || []).forEach(item=>{
            if(!item) return;
            if(item.key) wrongSet.add(item.key);
            const primary = toKey(item);
            if(primary) wrongSet.add(primary);
            const legacy = toLegacyKey(item);
            if(legacy) wrongSet.add(legacy);
          });
          const extras = [];
          const pickFromLevel = (levelIdx)=>{
            const candidates = allDeck.filter(q=> levelIndex(q.level) === levelIdx);
            const filteredCandidates = unitFilter
              ? candidates.filter(q=> normalizeUnit(q.unit) === unitFilter)
              : candidates;
            const prioritized = [];
            const others = [];
            for(const q of filteredCandidates){
              const key = toKey(q);
              if(!key) continue;
              if(seenKeys.has(key)) continue;
              seenKeys.add(key);
              const legacyKey = toLegacyKey(q);
              if(wrongSet.has(key) || (legacyKey && wrongSet.has(legacyKey))) prioritized.push(q);
              else others.push(q);
            }
            const prioritizedShuffled = prioritized.length ? shuffle(prioritized) : [];
            const othersShuffled = others.length ? shuffle(others) : [];
            const applyStageFPriorityOrdering = (list)=>{
              if(!Array.isArray(list) || !list.length) return list;
              const preferred = [];
              const rest = [];
              for(const item of list){
                const key = toKey(item);
                if(key && stageFHistory.has(key)) preferred.push(item);
                else rest.push(item);
              }
              return preferred.concat(rest);
            };
            const prioritizedOrdered = applyStageFPriorityOrdering(prioritizedShuffled);
            const othersOrdered = applyStageFPriorityOrdering(othersShuffled);
            const desiredTotalForExtras = baseDeckCount + extrasLimit;
            appendFallbackExtras(extras, prioritizedOrdered, othersOrdered, desiredTotalForExtras, baseDeckCount);
          };

          for(let levelIdx = maxLevelIdx + 1; levelIdx < LEVEL_ORDER.length; levelIdx++){
            pickFromLevel(levelIdx);
            if(baseDeckCount + extras.length >= baseDeckCount + extrasLimit) break;
          }

          state.fallbackExtras = extras;
          extras.forEach(q=>{
            const key = toKey(q);
            if(!key) return;
            fallbackStageOverrides.set(key, 'F');
          });
        }

        const currentExtraKeys = new Set((state.fallbackExtras || []).map(item=>toKey(item)).filter(Boolean));

        const deckArr = deck({ includeExtras: true });
        const targetCount = Math.min(desired, deckArr.length);

        const dueByStage = new Map(STAGE_PRIORITY.map(stage=>[stage, []]));
        const stageFPool = [];
        const levelBuckets = new Map();
        const stageByIndex = new Map();

        const entries = deckArr.map((q, idx)=>({
          idx,
          id: q && q.id ? String(q.id) : null,
        }));

        // API çµŒç”±ã§å„å•é¡Œã®å­¦ç¿’ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ã¾ã¨ã‚ã¦å–å¾—ã€‚
        const stats = await fetchStatsForEntries(entries, state.user);

        const now = Date.now();

        const pushLevelCandidate = (levelIdx, payload)=>{
          if(!Number.isFinite(levelIdx)) return;
          let bucket = levelBuckets.get(levelIdx);
          if(!bucket){
            bucket = [];
            levelBuckets.set(levelIdx, bucket);
          }
          bucket.push(payload);
        };

        for(let i=0;i<deckArr.length;i++){
          const question = deckArr[i];
          const levelIdx = levelIndex(question && question.level);
          const s = stats[i];
          if(!s || typeof s !== 'object'){
            stageByIndex.set(i, 'F');
            stageFPool.push({idx:i, streak:0});
            pushLevelCandidate(levelIdx, { idx:i, stage:'F', streak:0, nextDue:null, rand:Math.random() });
            continue;
          }

          const qKey = toKey(question);
          const hasFallbackOverride = qKey && fallbackStageOverrides.has(qKey);
          const hasHistoryOverride = qKey && stageFHistory.has(qKey);
          const actualStage = normalizeStage(s.stage);
          const overrideStage = hasFallbackOverride
            ? normalizeStage(fallbackStageOverrides.get(qKey))
            : (hasHistoryOverride ? 'F' : null);
          const stage = overrideStage || actualStage;
          stageByIndex.set(i, stage);
          const rawStreak = Number(s.streak);
          const baseStreak = Number.isFinite(rawStreak) ? rawStreak : 0;
          const streak = hasFallbackOverride ? 0 : baseStreak;
          const nextDue = parseIsoDate(s.nextDueAt);
          const nextDueMs = nextDue instanceof Date ? nextDue.getTime() : null;
          const isTrackedStageForWait = STAGE_PRIORITY.includes(actualStage);
          const isWaiting = isTrackedStageForWait && nextDueMs != null && nextDueMs > now;
          const willPromote = !overrideStage && willStageUpOnSuccess(actualStage, nextDue, now);
          if(isWaiting){
            if(qKey && currentExtraKeys.has(qKey)){
              blockedFallbackKeys.add(qKey);
            }
            continue;
          }
          const payload = { idx:i, stage, actualStage, streak, nextDue, rand:Math.random() };
          pushLevelCandidate(levelIdx, payload);
          if(willPromote){
            const arr = dueByStage.get(actualStage);
            if(arr){
              arr.push(payload);
              continue;
            }
          }

          if(stage === 'F'){
            stageFPool.push({ idx:i, streak });
          }else if(!STAGE_PRIORITY.includes(stage)){
            stageFPool.push({ idx:i, streak });
          }
        }

        const stageFShortage = stageFPool.length === 0;
        if(stageFShortage && !forcedStagePromotionAttempted && attempt < MAX_ATTEMPTS - 1){
          const hasHigherLevelCandidates = allDeck.some(q=> levelIndex(q.level) > maxLevelIdx);
          if(hasHigherLevelCandidates){
            forcedStagePromotionAttempted = true;
            const desiredExtras = Number.isFinite(desired) ? Math.max(1, Math.floor(desired)) : 1;
            forcedExtraDeficit = Math.max(forcedExtraDeficit, desiredExtras);
            continue;
          }
        }

        const n = targetCount;

        const order = [];
        const chosen = new Set();

        // ã‚¹ãƒ†ãƒ¼ã‚¸ç¹°ã‚Šä¸Šã’å¯¾è±¡ã¨ã‚¹ãƒ†ãƒ¼ã‚¸Fã®å€™è£œæ•°ã‹ã‚‰ã€ã‚¹ãƒ†ãƒ¼ã‚¸å„ªå…ˆæ ã‚’ç®—å‡ºã€‚
        const dueCandidateCount = STAGE_PRIORITY.reduce((acc, stage)=>{
          const arr = dueByStage.get(stage);
          return acc + (Array.isArray(arr) ? arr.length : 0);
        }, 0);
        const effectiveStageFCount = Math.max(0, stageFPool.length - dueCandidateCount);
        const baseStagePriorityQuota = typeof determineStagePriorityQuota === 'function'
          ? determineStagePriorityQuota(n, effectiveStageFCount)
          : Math.max(0, n - Math.min(effectiveStageFCount, n));
        let stagePriorityQuota = baseStagePriorityQuota;
        if(stagePriorityQuota < n && dueCandidateCount > 0){
          const minimumQuota = Math.min(
            n,
            Math.max(1, Math.min(dueCandidateCount, Math.ceil(n / 3)))
          );
          if(stagePriorityQuota < minimumQuota){
            stagePriorityQuota = minimumQuota;
          }
        }
        let stagePriorityPicked = 0;
        const lv2Index = LEVEL_ORDER.indexOf('Lv2');
        const normalizeRank = (stage)=>{
          if(stage === 'F') return -1;
          const idx = STAGE_PRIORITY.indexOf(stage);
          return idx === -1 ? STAGE_PRIORITY.length : idx;
        };

        // ã‚¹ãƒ†ãƒ¼ã‚¸é †ã«ç¹°ã‚Šä¸Šã’å€™è£œã‚’é¸æŠœã€‚
        for(const stage of STAGE_PRIORITY){
          if(stagePriorityPicked >= stagePriorityQuota) break;
          const arr = dueByStage.get(stage) || [];
          arr.sort((a,b)=>{
            const aDue = a.nextDue instanceof Date ? a.nextDue.getTime() : -Infinity;
            const bDue = b.nextDue instanceof Date ? b.nextDue.getTime() : -Infinity;
            if(aDue !== bDue) return aDue - bDue;
            return a.rand - b.rand;
          });
          for(const entry of arr){
            if(order.length >= n) break;
            if(stagePriorityPicked >= stagePriorityQuota) break;
            if(chosen.has(entry.idx)) continue;
            order.push({ idx:entry.idx, bucket:`Stage ${entry.stage}`, streak:entry.streak });
            chosen.add(entry.idx);
            stagePriorityPicked += 1;
          }
          if(order.length >= n) break;
        }

        const stageFTopUps = [];
        if(order.length < n){
          let stageFSlotsRemaining = Math.max(0, n - order.length);
          if(stageFSlotsRemaining > stageFPool.length && lv2Index !== -1){
            let stageFNeeded = stageFSlotsRemaining - stageFPool.length;
            const levelCandidates = (levelBuckets.get(lv2Index) || []).slice().sort((a,b)=>{
              const rankDiff = normalizeRank(a.stage) - normalizeRank(b.stage);
              if(rankDiff !== 0) return rankDiff;
              const aDue = a.nextDue instanceof Date ? a.nextDue.getTime() : Infinity;
              const bDue = b.nextDue instanceof Date ? b.nextDue.getTime() : Infinity;
              if(aDue !== bDue) return aDue - bDue;
              return a.rand - b.rand;
            });
            const prioritized = [];
            const general = [];
            for(const entry of levelCandidates){
              const question = deckArr[entry.idx];
              const key = toKey(question);
              if(key && stageFHistory.has(key)){
                prioritized.push({ entry, question });
              }else{
                general.push({ entry, question });
              }
            }
            const promoteCandidate = (entry, question)=>{
              if(stageFNeeded <= 0) return;
              if(chosen.has(entry.idx)) return;
              const key = toKey(question);
              if(key) fallbackStageOverrides.set(key, 'F');
              stageByIndex.set(entry.idx, 'F');
              stageFTopUps.push({ idx:entry.idx, streak:entry.streak });
              stageFNeeded -= 1;
            };
            for(const candidate of prioritized){
              promoteCandidate(candidate.entry, candidate.question);
              if(stageFNeeded <= 0) break;
            }
            if(stageFNeeded > 0){
              for(const candidate of general){
                promoteCandidate(candidate.entry, candidate.question);
                if(stageFNeeded <= 0) break;
              }
            }
          }
        }

        const prioritizeStageFPool = (list)=>{
          if(!Array.isArray(list) || !list.length) return [];
          const preferred = [];
          const others = [];
          for(const entry of list){
            const question = deckArr[entry.idx];
            const key = toKey(question);
            if(key && stageFHistory.has(key)) preferred.push(entry);
            else others.push(entry);
          }
          const shuffledPreferred = preferred.length ? shuffle(preferred) : [];
          const shuffledOthers = others.length ? shuffle(others) : [];
          return shuffledPreferred.concat(shuffledOthers);
        };
        const shuffledF = prioritizeStageFPool(stageFPool.concat(stageFTopUps));
        for(const entry of shuffledF){
          if(order.length >= n) break;
          if(chosen.has(entry.idx)) continue;
          order.push({ idx:entry.idx, bucket:'Stage F', streak:entry.streak });
          chosen.add(entry.idx);
        }

        if(order.length < n){
          // ã¾ã æ ãŒåŸ‹ã¾ã‚‰ãªã„å ´åˆã€ä¸Šä½ãƒ¬ãƒ™ãƒ«ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ è£œå……ã€‚
          const levelRanks = Array.from(levelBuckets.keys())
            .filter(idx=>Number.isFinite(idx))
            .sort((a,b)=>b-a);
          for(const levelIdx of levelRanks){
            if(levelIdx === lv2Index) continue;
            const levelCandidates = (levelBuckets.get(levelIdx) || []).slice().sort((a,b)=>{
              const rankDiff = normalizeRank(a.stage) - normalizeRank(b.stage);
              if(rankDiff !== 0) return rankDiff;
              const aDue = a.nextDue instanceof Date ? a.nextDue.getTime() : Infinity;
              const bDue = b.nextDue instanceof Date ? b.nextDue.getTime() : Infinity;
              if(aDue !== bDue) return aDue - bDue;
              return a.rand - b.rand;
            });
            const levelLabel = LEVEL_ORDER[levelIdx] || '';
            for(const entry of levelCandidates){
              if(order.length >= n) break;
              if(chosen.has(entry.idx)) continue;
              const bucketLabel = levelLabel ? `Lvå„ªå…ˆ (${levelLabel})` : 'Lvå„ªå…ˆ';
              order.push({ idx:entry.idx, bucket:bucketLabel, streak:entry.streak });
              chosen.add(entry.idx);
            }
            if(order.length >= n || chosen.size === deckArr.length) break;
          }
        }

        // ä»Šå›æ¡ç”¨ã—ãŸã‚¹ãƒ†ãƒ¼ã‚¸Fã®å•é¡Œã‚’è¨˜éŒ²ã—ã€æ¬¡å›ä»¥é™ã®å„ªå…ˆåº¦ã«åæ˜ ã€‚
        const stageFKeysToRemember = [];
        const seenStageFKeys = new Set();
        for(const entry of order){
          const stage = stageByIndex.get(entry.idx);
          if(stage !== 'F') continue;
          const question = deckArr[entry.idx];
          const key = toKey(question);
          if(!key || seenStageFKeys.has(key)) continue;
          seenStageFKeys.add(key);
          stageFKeysToRemember.push(key);
        }
        if(stageFKeysToRemember.length){
          rememberStageFKeys(stageFKeysToRemember);
        }

        lastOrder = order;

        if(order.length < targetCount){
          const shortage = targetCount - order.length;
          if(shortage > 0 && attempt < MAX_ATTEMPTS - 1){
            forcedExtraDeficit = Math.max(0, forcedExtraDeficit) + shortage;
            continue;
          }
        }

        return order;
      }

      return lastOrder;
    }






    function buildOrderFromWrong(strategy='all'){
      const wrong=getWrongQueue();
      if(wrong.length===0) return [];
      const need = Math.min(state.totalPerSet, wrong.length);
      let pool = [];
      if(strategy==='recent'){
        const cutoff = Date.now() - 7*24*3600*1000;
        const recent = wrong.filter(x=> x.at && (new Date(x.at).getTime()>=cutoff))
                            .sort((a,b)=> new Date(b.at)-new Date(a.at));
        pool = recent.slice(0, need);
        if(pool.length < need){
          const rest = wrong.filter(x=> !pool.includes(x));
          pool = pool.concat(rest.slice(0, need - pool.length));
        }
      }else{
        pool = wrong.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]).slice(0, need);
      }
      window.__REVIEW_DECK__ = pool.map(w=>({ ...w }));
      return [...window.__REVIEW_DECK__.keys()];
    }

    async function createOrderEntriesFromIndexes(indexes, deckArray, bucketValue=null){
      if(!Array.isArray(indexes) || indexes.length===0){
        return [];
      }
      const trimmedUser = (state.user || '').trim();
      const questions = Array.isArray(deckArray) ? deckArray : [];
      const baseEntries = indexes.map(idx=>{
        const question = questions[idx];
        const hasId = question && question.id != null;
        return {
          idx,
          bucket: bucketValue,
          streak: 0,
          id: hasId ? String(question.id) : null,
        };
      });
      const hasUser = !!trimmedUser;
      const hasIds = baseEntries.some(entry=> entry.id);
      if(hasUser && hasIds){
        try{
          const stats = await fetchStatsForEntries(baseEntries, trimmedUser);
          stats.forEach((stat, i)=>{
            const entry = baseEntries[i];
            if(!entry || !stat || typeof stat !== 'object') return;
            const raw = Number(stat.streak);
            if(Number.isFinite(raw)){
              entry.streak = Math.max(0, raw);
            }
          });
        }catch(err){
          console.warn('å•é¡Œã®é€£ç¶šæ­£è§£ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ', err);
        }
      }
      return baseEntries.map(({idx, bucket, streak})=>({ idx, bucket, streak }));
    }

    // === æˆç¸¾ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ï¼‰: éå»ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å¼±ç‚¹æŠ½å‡º ===
    const PERF_KEY = (u)=>`quiz:${u}:perf`;
    function loadPerf(){ return JSON.parse(localStorage.getItem(PERF_KEY(state.user))||'{}'); }
    function savePerf(p){ localStorage.setItem(PERF_KEY(state.user), JSON.stringify(p)); }
    function noteAttempt(q, correct, at, mode){
      if(mode==='review') return; // å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰ã¯è¨˜éŒ²ã—ãªã„
      const p = loadPerf();
      const k = questionKey(q);
      const rec = p[k] || { id:q.id||null, type:q.type, jp:q.jp, en:q.en, unit:q.unit||null, attempts:[] };
      rec.attempts.push({ correct: !!correct, at });
      const cutoff = Date.now() - 30*24*3600*1000; // 30æ—¥ã§ãƒ­ãƒ¼ãƒ†
      rec.attempts = rec.attempts.filter(a=> new Date(a.at).getTime() >= cutoff);
      p[k]=rec; savePerf(p);
    }
    function updateQuestionStat(q, bucket){
      const elStreak = $('#stat-streak');
      const elAcc = $('#stat-accuracy');
      const elBucket = $('#stat-bucket');
      const elStage = $('#stat-stage');
      elBucket.textContent = bucket ? `ãƒã‚±ãƒƒãƒˆ: ${bucket}` : 'ãƒã‚±ãƒƒãƒˆ: --';
      elStage.textContent = 'ã‚¹ãƒ†ãƒ¼ã‚¸: --';
      if(!state.user || !q.id){
        elStreak.textContent='é€£ç¶šæ­£è§£: --';
        elAcc.textContent='æ­£è§£ç‡: --';
        return;
      }
      fetch(`/api/stats?user=${encodeURIComponent(state.user)}&id=${encodeURIComponent(q.id)}&subject=${encodeURIComponent(SUBJECT)}`, {cache:'no-store'})
        .then(res=>res.ok?res.json():null)
        .then(data=>{
          if(!data){
            elStreak.textContent='é€£ç¶šæ­£è§£: --';
            elAcc.textContent='æ­£è§£ç‡: --';
            elStage.textContent='ã‚¹ãƒ†ãƒ¼ã‚¸: --';
            return;
          }
          const ans=data.answered||0; const ok=data.correct||0;
          elStreak.textContent = `é€£ç¶šæ­£è§£: ${data.streak||0}`;
          elAcc.textContent = ans? `æ­£è§£ç‡: ${Math.round((ok/ans)*100)}% (${ok}/${ans})` : 'æ­£è§£ç‡: --';
          elStage.textContent = data.stage ? `ã‚¹ãƒ†ãƒ¼ã‚¸: ${data.stage}` : 'ã‚¹ãƒ†ãƒ¼ã‚¸: --';
        })
        .catch(()=>{
          elStreak.textContent='é€£ç¶šæ­£è§£: --';
          elAcc.textContent='æ­£è§£ç‡: --';
          elStage.textContent='ã‚¹ãƒ†ãƒ¼ã‚¸: --';
        });
    }
    function weakCandidates(windowDays){
      const p = loadPerf();
      const cut = Date.now() - (windowDays*24*3600*1000);
      const list = [];
      const d = deck();
      for(const q of d){
        const k = questionKey(q);
        const rec = p[k];
        if(!rec || !rec.attempts || rec.attempts.length===0) continue;
        const arr = rec.attempts.filter(a=> new Date(a.at).getTime() >= cut);
        if(arr.length===0) continue;
        const wrong = arr.filter(a=>!a.correct).length;
        const acc = (arr.length - wrong)/arr.length;
        list.push({ q, acc, attempts: arr.length, wrong, lastAt: arr[arr.length-1].at });
      }
      // ä½æ­£ç­”ç‡ â†’ è©¦è¡Œå›æ•°å¤š â†’ æœ€è¿‘ ã®é †
      list.sort((a,b)=> (a.acc - b.acc) || (b.attempts - a.attempts) || (new Date(b.lastAt)-new Date(a.lastAt)) );
      return list;
    }
    async function buildOrderWeak(windowDays=7){
      const stats = weakCandidates(windowDays);
      if(stats.length===0) return [];

      const entries = stats.map((item, idx)=>({
        idx,
        id: item && item.q && item.q.id != null ? String(item.q.id) : null,
      }));

      let filtered = stats.slice();
      const trimmedUser = (state.user || '').trim();
      const hasIds = entries.some(entry => entry.id);
      if(trimmedUser && hasIds){
        const stageStats = await fetchStatsForEntries(entries, trimmedUser);
        const nowMs = Date.now();
        filtered = stats.filter((item, idx)=>{
          const stat = stageStats[idx];
          if(!stat || typeof stat !== 'object') return true;
          const stage = normalizeStage(stat.stage);
          const nextDue = parseIsoDate(stat.nextDueAt);
          const nextDueMs = nextDue instanceof Date ? nextDue.getTime() : null;
          const isTrackedStage = STAGE_PRIORITY.includes(stage);
          return !(isTrackedStage && nextDueMs != null && nextDueMs > nowMs);
        });
      }

      if(filtered.length===0) return [];

      const pick = filtered.slice(0, Math.min(state.totalPerSet, filtered.length)).map(s=>s.q);
      window.__WEAK_DECK__ = pick;
      return pick.map((_,i)=>i);
    }

    async function startSet(){
      try{ await ensureQuestions(); }catch(e){ alert(e.message||e); return; }
      state.fallbackExtras = [];
      const fullDeck = deckByType(state.qType);
      if(!fullDeck.length){ alert(`ã“ã®å‡ºé¡Œã‚¿ã‚¤ãƒ—ã®å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“ã€‚/data/${SUBJECT}/questions.json ã‚’ã”ç¢ºèªãã ã•ã„ã€‚`); show('setup'); return; }
      state.qIndex=0; state.correct=0; state.wrong=0; state.answered=[]; state.reviewed=[]; state.graded=false; state.choiceSelection=null;
      $('#stat-correct').textContent='0'; $('#stat-wrong').textContent='0';
      if(state.mode==='review'){
        const ord = buildOrderFromWrong(state.reviewStrategy||'all');
        if(ord.length===0){ alert('å¾©ç¿’ã™ã‚‹å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãšã¯é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã§é–“é•ã„ã‚’ãŸã‚ã¾ã—ã‚‡ã†ã€‚'); show('setup'); return; }
        state.order = await createOrderEntriesFromIndexes(ord, window.__REVIEW_DECK__);
      }else if(state.mode==='weak'){
        const ord = await buildOrderWeak(state.weakWindowDays||7);
        if(ord.length===0){ alert('å¼±ç‚¹å€™è£œãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆæœ€è¿‘ã®ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ï¼‰ã€‚é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã§è§£ã„ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å¢—ã‚„ã—ã¾ã—ã‚‡ã†ã€‚'); show('setup'); return; }
        state.order = await createOrderEntriesFromIndexes(ord, window.__WEAK_DECK__);
      }else{
        state.order = await buildOrderFromBank();
        if(!state.order.length){
          alert('é¸æŠã—ãŸæ¡ä»¶ã«åˆã†å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“ã€‚æ¡ä»¶ã‚’è¦‹ç›´ã—ã¦ãã ã•ã„ã€‚');
          show('setup');
          return;
        }
      }
      show('quiz'); startTimer(); renderQuestion();
    }

    /********** å‡ºé¡Œï¼†UI **********/
    function getCurrentQuestion(){
      const entry = state.order[state.qIndex] || { idx:0, bucket:null, streak:0 };
      const idx = entry.idx;
      if(state.mode==='review') return window.__REVIEW_DECK__[idx];
      if(state.mode==='weak') return window.__WEAK_DECK__[idx];
      return deck()[idx];
    }

    function startTimer(){ state.startedAt=Date.now(); if(state.timerId) clearInterval(state.timerId); state.timerId=setInterval(()=>{ const sec=Math.floor((Date.now()-state.startedAt)/1000); $('#timer').textContent=`â± ${fmtTime(sec)}`; }, 250); }
    function stopTimer(){ if(state.timerId){ clearInterval(state.timerId); state.timerId=null; } }

    function updateChoiceButtons(){
      const options = $$('#vocab-choice-options .choice-option');
      const selectedValue = state.choiceSelection || '';
      options.forEach(btn=>{
        const value = btn.getAttribute('data-value') || '';
        const isSelected = value === selectedValue;
        const indexAttr = parseInt(btn.getAttribute('data-index') || '1', 10) - 1;
        btn.classList.toggle('selected', isSelected);
        btn.setAttribute('aria-checked', isSelected ? 'true' : 'false');
        btn.tabIndex = (isSelected || (!selectedValue && indexAttr === 0)) ? 0 : -1;
      });
    }

    function selectChoice(value){
      if(state.choiceSelection === value){
        state.choiceSelection = null;
      } else {
        state.choiceSelection = value;
      }
      updateChoiceButtons();
      updateNextState();
    }
    function renderReorderQuestion(q, entry){
      entry = entry || {};
      $('#ui-reorder').style.display='block';
      $('#ui-vocab-choice').style.display='none';
      $('#ui-rewrite').style.display='none';
      const basePrompt = q.jp || '<span class="muted">èªé †ã‚’ä¸¦ã¹æ›¿ãˆã¾ã—ã‚‡ã†</span>';
      $('#prompt').innerHTML = basePrompt;
      $('#btn-hint').disabled = !q.tip;
      const target=$('#target');
      const bank=$('#bank');
      target.innerHTML='';
      bank.innerHTML='';
      let chunks = q.chunks.slice();
      if(entry.streak >= HARD_STREAK && q.wrong && q.wrong.length>0){
        const w = q.wrong[Math.floor(Math.random()*q.wrong.length)];
        chunks = chunks.concat(w);
      }
      chunks = shuffle(chunks);
      chunks.forEach((c,i)=>{
        const chip=document.createElement('button');
        chip.className='chip';
        chip.setAttribute('data-text',c);
        chip.textContent=`${i+1}. ${c}`;
        chip.onclick=()=>placeChip(chip);
        bank.appendChild(chip);
        chip.draggable=true;
        chip.ondragstart=e=>{ e.dataTransfer.setData('text/plain', c); chip.classList.add('dragging'); };
        chip.ondragend=()=>chip.classList.remove('dragging');
      });
      $('#target').ondragover=e=>{ e.preventDefault(); };
      $('#target').ondrop=e=>{
        e.preventDefault();
        const text=e.dataTransfer.getData('text/plain');
        const src=[...$$('#bank .chip')].find(ch=>ch.getAttribute('data-text')===text && !ch.classList.contains('used'));
        if(src) placeChip(src);
      };
      $('#btn-next').disabled = true;
    }

    function placeChip(chip){
      if(!chip || chip.classList.contains('used')) return;
      chip.classList.add('used');
      const btn=document.createElement('button');
      btn.className='chip';
      btn.textContent=chip.getAttribute('data-text');
      btn.onclick=()=>{
        btn.remove();
        chip.classList.remove('used');
        updateNextState();
      };
      $('#target').appendChild(btn);
      updateNextState();
    }


    function prepareVocabChoiceOptions(q, entry){
      entry = entry || {};
      const optionMap = new Map();
      const correctTexts = [];
      const addCorrectText = text=>{
        const trimmed = (text||'').trim();
        if(!trimmed) return;
        if(!correctTexts.includes(trimmed)) correctTexts.push(trimmed);
      };
      addCorrectText(q.jp);
      if(Array.isArray(q.answers)){
        q.answers.forEach(ans=>addCorrectText(ans));
      }
      const ensureOption = (text, correct)=>{
        const trimmed = (text||'').trim();
        if(!trimmed) return;
        const isCorrect = correct === true || correctTexts.includes(trimmed);
        if(optionMap.has(trimmed)){
          const existing = optionMap.get(trimmed);
          if(isCorrect && !existing.correct){
            existing.correct = true;
          }
          return;
        }
        optionMap.set(trimmed, { text: trimmed, correct: isCorrect });
      };
      if(Array.isArray(q.choices) && q.choices.length){
        q.choices.forEach(choice=>{
          if(!choice || typeof choice.text !== 'string') return;
          const trimmed = choice.text.trim();
          if(!trimmed) return;
          if(choice.correct === true){
            addCorrectText(trimmed);
          }
          ensureOption(trimmed, choice.correct === true);
        });
      }
      if(optionMap.size === 0 && correctTexts.length){
        ensureOption(correctTexts[0], true);
      }
      if(!Array.from(optionMap.values()).some(opt=>opt.correct) && optionMap.size){
        const match = Array.from(optionMap.values()).find(opt=>correctTexts.includes(opt.text));
        if(match){
          match.correct = true;
        } else {
          const first = optionMap.values().next().value;
          if(first) first.correct = true;
        }
      }
      const allOptions = Array.from(optionMap.values());
      const availableCount = allOptions.length;
      const rawEntryStreak = entry && entry.streak != null ? Number(entry.streak) : 0;
      const entryStreak = Number.isFinite(rawEntryStreak) ? rawEntryStreak : 0;
      const streak = Math.max(0, entryStreak);
      const targetCount = streak + MIN_VOCAB_CHOICE_OPTIONS;
      const baseDesired = Math.max(1, Math.min(availableCount, targetCount));
      const correctOptions = allOptions.filter(opt=>opt.correct);
      const desiredCount = Math.max(baseDesired, correctOptions.length);
      const shuffledCorrect = shuffle(correctOptions);
      const incorrectOptions = allOptions.filter(opt=>!opt.correct);
      const shuffledIncorrect = shuffle(incorrectOptions);
      const selected = [];
      shuffledCorrect.forEach(opt=>{ selected.push(opt); });
      for(const opt of shuffledIncorrect){
        if(selected.length >= desiredCount) break;
        selected.push(opt);
      }
      if(selected.length < Math.min(desiredCount, availableCount)){
        for(const opt of shuffledCorrect){
          if(selected.length >= desiredCount) break;
          if(!selected.includes(opt)) selected.push(opt);
        }
      }
      return shuffle(selected);
    }


    function renderVocabChoiceQuestion(q, entry){
      $('#ui-reorder').style.display='none';
      $('#ui-vocab-choice').style.display='block';
      $('#ui-rewrite').style.display='none';
      const word = q.en || '<span class="muted">è‹±å˜èªã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†</span>';
      const pos = q.pos ? `<span class="muted">ï¼ˆ${q.pos}ï¼‰</span>` : '';
      $('#prompt').innerHTML = `è‹±å˜èª: <b>${word}</b> ${pos}`;
      $('#vocab-choice-tip').textContent = '';
      $('#btn-hint').disabled = !q.tip;
      const optionsEl = $('#vocab-choice-options');
      optionsEl.innerHTML='';
      const finalOptions = prepareVocabChoiceOptions(q, entry);
      finalOptions.forEach((opt, idx)=>{
        const btn = document.createElement('button');
        btn.type='button';
        btn.className='choice-option';
        btn.setAttribute('data-value', opt.text);
        btn.setAttribute('data-index', String(idx+1));
        btn.setAttribute('role', 'radio');
        btn.setAttribute('aria-checked', 'false');
        btn.tabIndex = idx === 0 ? 0 : -1;
        btn.textContent = `${idx+1}. ${opt.text}`;
        btn.onclick=()=>selectChoice(opt.text);
        optionsEl.appendChild(btn);
      });
      updateChoiceButtons();
      const firstOption = $('#vocab-choice-options .choice-option');
      if(firstOption){ firstOption.focus(); }
      $('#btn-next').disabled = true;
    }


    function renderRewriteQuestion(q){
      $('#ui-reorder').style.display='none';
      $('#ui-vocab-choice').style.display='none';
      $('#ui-rewrite').style.display='block';
      const instruction = q.jp || '<span class="muted">æŒ‡ç¤ºã«å¾“ã£ã¦è‹±æ–‡ã‚’æ›¸ãæ›ãˆã¾ã—ã‚‡ã†</span>';
      $('#prompt').innerHTML = instruction;
      const extras = [];
      if(q.source) extras.push(`å…ƒã®æ–‡: <b>${q.source}</b>`);
      if(q.task) extras.push(`æŒ‡å®š: ${q.task}`);
      if(q.note) extras.push(q.note);
      $('#rewrite-extra').innerHTML = extras.join('<br>');
      $('#rewrite-tip').innerHTML = '';
      $('#btn-hint').disabled = !q.tip;
      const area = $('#rewrite-input');
      area.value='';
      area.focus();
      $('#btn-next').disabled = false;
    }


    function showHint(){
      const q = getCurrentQuestion();
      if(!q || !q.tip) return;
      if(state.qType==='reorder'){
        const base = q.jp || '<span class="muted">èªé †ã‚’ä¸¦ã¹æ›¿ãˆã¾ã—ã‚‡ã†</span>';
        $('#prompt').innerHTML = `${base}<br><span class="muted">ãƒ’ãƒ³ãƒˆ: ${q.tip}</span>`;
      } else if(state.qType==='vocab-choice'){
        $('#vocab-choice-tip').textContent = `ãƒ’ãƒ³ãƒˆ: ${q.tip}`;
      } else if(state.qType==='rewrite'){
        $('#rewrite-tip').innerHTML = `ãƒ’ãƒ³ãƒˆ: ${q.tip}`;
      }
    }


    function undo(){
      if(state.qType!=='reorder') return;
      const chips = $$('#target .chip');
      const last = chips[chips.length-1];
      if(!last) return;
      const text = last.textContent;
      last.remove();
      const bankChip = [...$$('#bank .chip')].find(c=>c.getAttribute('data-text')===text);
      if(bankChip) bankChip.classList.remove('used');
      updateNextState();
    }


    function clearAnswer(){
      if(state.qType==='reorder'){
        $$('#target .chip').forEach(node=>node.remove());
        $$('#bank .chip').forEach(node=>node.classList.remove('used'));
        updateNextState();
      } else if(state.qType==='vocab-choice'){
        state.choiceSelection = null;
        updateChoiceButtons();
        const firstOption = $('#vocab-choice-options .choice-option');
        if(firstOption){ firstOption.focus(); }
        updateNextState();
      } else {
        const inp = typedInputElement();
        if(inp){ inp.value=''; inp.focus(); }
        updateNextState();
      }
    }


    function currentAnswer(){
      if(state.qType==='reorder'){
        return [...$('#target').children].map(x=>x.textContent).join(' ');
      }
      if(state.qType==='vocab-choice'){
        return state.choiceSelection || '';
      }
      const inp = typedInputElement();
      return inp ? (inp.value || '') : '';
    }


    function renderQuestion(){
      const entry = state.order[state.qIndex] || {};
      const q = getCurrentQuestion();
      updateQuestionStat(q, entry.bucket);
      state.graded = false;
      state.choiceSelection = null;
      $('#status').textContent = `Q ${state.qIndex+1}/${state.order.length}${state.mode==='review'?'ï¼ˆå¾©ç¿’ï¼‰':''}`;
      $('#explain').textContent='';

      if(state.qType==='reorder'){
        renderReorderQuestion(q, entry);
      } else if(state.qType==='vocab-choice'){
        renderVocabChoiceQuestion(q, entry);
      } else if(state.qType==='rewrite'){
        renderRewriteQuestion(q);
      }
      updateNextState();
    }

    function updateNextState(){
      const btnCheck = $('#btn-check');
      const btnNext = $('#btn-next');
      if(!btnCheck || !btnNext) return;
      if(state.qType==='reorder'){
        const hasAnswer = $$('#target .chip').length > 0;
        btnCheck.disabled = state.graded || !hasAnswer;
        btnNext.disabled = state.graded ? false : true;
      } else if(state.qType==='vocab-choice'){
        const hasSelection = !!(state.choiceSelection && state.choiceSelection.trim());
        btnCheck.disabled = state.graded || !hasSelection;
        btnNext.disabled = state.graded ? false : true;
      } else {
        const inp = typedInputElement();
        const value = inp ? (inp.value || '').trim() : '';
        btnCheck.disabled = state.graded || value.length===0;
        btnNext.disabled = false;
      }
    }

    function buildFeedbackDetail(q, includeTip=false){
      const lines = [];
      if(q.explain) lines.push(q.explain);
      if(includeTip && q.tip) lines.push(q.tip);
      if(lines.length===0) return '';
      return '<br>' + lines.map(text=>`<span class="muted">${text}</span>`).join('<br>');
    }

    function formatCorrectAnswers(list){
      const answers = (Array.isArray(list)? list : [list]).filter(Boolean);
      if(!answers.length) return '<span class="muted">ï¼ˆæ­£è§£æœªè¨­å®šï¼‰</span>';
      if(answers.length===1) return `<b>${answers[0]}</b>`;
      return answers.map(ans=>`<b>${ans}</b>`).join('<br><span class="muted">ã¾ãŸã¯</span> ');
    }

    function collectVocabChoiceCorrectAnswers(q){
      const answers = new Set();
      const push = text=>{
        const trimmed = (text||'').trim();
        if(trimmed) answers.add(trimmed);
      };
      push(q.jp);
      if(Array.isArray(q.answers)){
        q.answers.forEach(push);
      }
      if(Array.isArray(q.choices)){
        q.choices.forEach(choice=>{
          if(choice && choice.correct === true && typeof choice.text === 'string'){
            push(choice.text);
          }
        });
      }
      return Array.from(answers);
    }

    /********** æ¡ç‚¹ãƒ»é€²è¡Œ **********/
    function checkAnswer(){
      if(state.graded) return; // äºŒé‡åŠ ç®—é˜²æ­¢
      const q = getCurrentQuestion();

      const answerList = state.qType==='vocab-choice'
        ? collectVocabChoiceCorrectAnswers(q)
        : ((Array.isArray(q.answers) && q.answers.length) ? q.answers : [q.en]);
      let ans, correct;
      if(state.qType==='reorder'){
        const keepPunc = true; // ä¸¦ã³æ›¿ãˆã§ã¯æ–‡æœ«è¨˜å·ã‚’ä¿æŒã™ã‚‹
        const normalizedAns = normalizeEndPunc(normalizeSpaces(currentAnswer()), keepPunc);
        ans = normalizedAns? normalizedAns.charAt(0).toUpperCase()+normalizedAns.slice(1) : normalizedAns;
        const normalizedAnswers = answerList.map(a=>normalizeEndPunc(normalizeSpaces(a), keepPunc));
        const normalizedAnsLower = typeof normalizedAns === 'string' ? normalizedAns.toLowerCase() : normalizedAns;
        const normalizedAnswersLower = normalizedAnswers.map(a=>typeof a === 'string' ? a.toLowerCase() : a);
        correct = normalizedAnswersLower.includes(normalizedAnsLower);
      } else if(state.qType==='vocab-choice'){
        ans = normalizeSpaces(currentAnswer());
        const normalizedCorrect = answerList.map(a=>normalizeSpaces(a));
        correct = normalizedCorrect.includes(ans);
      } else if(state.qType==='rewrite'){
        const keepPunc = true;
        const normalizedAns = normalizeEndPunc(normalizeSpaces(currentAnswer()), keepPunc);
        ans = normalizedAns? normalizedAns.charAt(0).toUpperCase()+normalizedAns.slice(1) : normalizedAns;
        const normalizedAnswers = answerList.map(a=>normalizeEndPunc(normalizeSpaces(a), keepPunc));
        const normalizedAnsLower = typeof normalizedAns === 'string' ? normalizedAns.toLowerCase() : normalizedAns;
        const normalizedAnswersLower = normalizedAnswers.map(a=>typeof a === 'string' ? a.toLowerCase() : a);
        correct = normalizedAnswersLower.includes(normalizedAnsLower);
      }

      const record = {
        type: state.qType,
        id: q.id||null,
        unit: q.unit||null,
        userAnswer: ans,
        correct,
        setIndex: state.setIndex, qIndex: state.qIndex, mode: (state.mode||'normal'),
        at: nowISO()
      };

      if(correct){
        state.correct++; $('#stat-correct').textContent = state.correct;
        const detail = buildFeedbackDetail(q, false);
        $('#explain').innerHTML = `âœ… æ­£è§£ï¼ <span class="muted">${ans}</span>${detail}`;
        removeFromWrongIfMatched({id:q.id, jp:q.jp, en:q.en});
      } else {
        state.wrong++; $('#stat-wrong').textContent = state.wrong;
        const detail = buildFeedbackDetail(q, true);
        const answersMarkup = formatCorrectAnswers(answerList);
        $('#explain').innerHTML = state.qType==='reorder'
          ? `âŒ ä¸æ­£è§£ã€‚ æ­£è§£: ${answersMarkup}${detail}`
          : `âŒ ä¸æ­£è§£ã€‚ æ­£è§£: ${answersMarkup}${detail}`;
        // å¾©ç¿’ç”¨ã«ã¯è©³ç´°ä¿æŒ
        addWrongLocal({ type:state.qType, id:q.id||null, unit:q.unit||null, level:q.level||DEFAULT_LEVEL, jp:q.jp, en:q.en, chunks:q.chunks, tip:q.tip||'', explain:q.explain||'', source:q.source||'', task:q.task||'', userAnswer: ans, at: record.at });
      }

      (state.mode==='review'? state.reviewed : state.answered).push(record);
      noteAttempt(q, correct, record.at, state.mode);
      updateQuestionStat(q, state.order[state.qIndex].bucket);
      state.graded = true;
      $('#btn-next').disabled = false;
      updateNextState();
    }

    function nextQuestion(){
      if(!state.graded) checkAnswer();
      state.qIndex++;
      if(state.qIndex >= state.order.length){ finishSet(); }
      else { renderQuestion(); }
    }

    function finishSet(){
      stopTimer();
      const total = state.order.length;
      const accuracy = total? Math.round((state.correct/total)*100):0;
      const seconds = Math.floor((Date.now()-state.startedAt)/1000);
      $('#summary').innerHTML = `æ­£è§£ <b>${state.correct}</b> / ${total}ï¼ˆ<b>${accuracy}%</b>ï¼‰ãƒ»æ‰€è¦æ™‚é–“ ${Math.floor(seconds/60)}åˆ†${seconds%60}ç§’`;
      show('finished');

      // --- ã“ã®ã‚»ãƒƒãƒˆã®èª¤ç­”ã ã‘ã‚’æŠ½å‡ºã—ã¦ãƒœã‚¿ãƒ³ã«æ¸¡ã™ ---
      const srcDeck = (state.mode==='review') ? window.__REVIEW_DECK__
                    : (state.mode==='weak')  ? window.__WEAK_DECK__
                    : deck();

      // è§£ç­”è¨˜éŒ²ï¼ˆé€šå¸¸ or å¾©ç¿’ï¼‰ã® qIndex ã¯ã€Œstate.order ä¸Šã®ä½ç½®ã€
      const records = (state.mode==='review') ? state.reviewed : state.answered;
      const missedObjs = records
        .filter(r=>!r.correct)
        .map(r=>{
          const idxInSrc = state.order[r.qIndex].idx;
          return srcDeck[idxInSrc];
        })
        .filter(Boolean);

      // çŠ¶æ…‹ã«ä¿æŒã—ã¦ã€ãƒœã‚¿ãƒ³è¡¨ç¤ºã‚’æ›´æ–°
      state.missedSetDeck = missedObjs;
      const btnReviewThis = document.getElementById('btn-review-thisset');
      if(btnReviewThis){
        const n = missedObjs.length;
        btnReviewThis.disabled = (n===0);
        btnReviewThis.textContent = n
          ? `â—ã“ã®ã‚»ãƒƒãƒˆã®ã¾ã¡ãŒã„ã§å¾©ç¿’ï¼ˆ${n}å•ï¼‰`
          : `â—ã“ã®ã‚»ãƒƒãƒˆã®ã¾ã¡ãŒã„ã§å¾©ç¿’ï¼ˆ0å•ï¼‰`;
      }

      const wireAnswered = state.answered.map(({type,id,unit,userAnswer,correct,setIndex,qIndex,mode,at})=>({type,id,unit,userAnswer,correct,setIndex,qIndex,mode,at}));
      const wireReviewed = state.reviewed.map(({type,id,unit,userAnswer,correct,setIndex,qIndex,mode,at})=>({type,id,unit,userAnswer,correct,setIndex,qIndex,mode,at}));
      const wireCorrect  = wireAnswered.filter(x=>x.correct);
      const wireMissed   = wireAnswered.filter(x=>!x.correct);
      const wireReviewMissed = wireReviewed.filter(x=>!x.correct);

      const sessionWire = {
        user: state.user,
        setIndex: state.setIndex,
        mode: state.mode||'normal',
        qType: state.qType,
        total,
        correct: state.correct,
        wrong: total - state.correct,
        accuracy,
        seconds,
        endedAt: nowISO(),
        answered: wireAnswered,
        correctItems: wireCorrect,
        missed: wireMissed,
        reviewed: wireReviewed,
        reviewMissed: wireReviewMissed
      };

      // ãƒ­ãƒ¼ã‚«ãƒ«å±¥æ­´ã¯ã‚µãƒãƒªã®ã¿ï¼ˆè»½é‡ï¼‰
      pushHistory({ user: state.user, setIndex: state.setIndex, mode: state.mode||'normal', qType: state.qType, total, correct: state.correct, wrong: total-state.correct, accuracy, seconds, endedAt: sessionWire.endedAt });

      const saveEl = document.getElementById('save-status');
      const url = state.endpoint || DEFAULT_ENDPOINT;
      if(url){
        saveEl.textContent = 'çµæœé€ä¿¡: é€ä¿¡ä¸­â€¦';
        const payload = { ...sessionWire, subject: SUBJECT };
        console.log('[POST] results =>', url, payload);
        postJSON(url, payload).then(r=>{
          if(r.ok){ saveEl.innerHTML = '<span class="ok">çµæœé€ä¿¡: æˆåŠŸ</span>'; }
          else { saveEl.innerHTML = `<span class=\"ng\">çµæœé€ä¿¡: å¤±æ•—</span> ${r.status||r.error||''}`; }
        });
      } else {
        saveEl.textContent = 'çµæœé€ä¿¡: URLæœªè¨­å®šï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ã®ã¿ï¼‰';
      }
    }

    /********** ã‚¤ãƒ™ãƒ³ãƒˆ **********/
    document.getElementById('btn-start').onclick=async ()=>{
      try{
        state.user=(document.getElementById('learner').value||'guest').trim()||'guest';
        document.getElementById('user-pill').textContent=`ğŸ‘¤ ${state.user}`;
        clearStageFHistoryCache();
        clearWrongQueueCache();
        state.totalPerSet=Math.max(3,Math.min(20,parseInt(document.getElementById('count').value||7,10)));
        state.endpoint=DEFAULT_ENDPOINT;
        state.setIndex=0; state.mode='normal'; state.qType=document.getElementById('qtype').value||'reorder';
        const unitSel=document.getElementById('unit-filter');
        if(unitSel){
          const selected=(unitSel.value||'').trim();
          if(BANK_REORDER.length || BANK_VOCAB_CHOICE.length || !state.unitFilter){
            state.unitFilter=selected;
          }
        }
        rememberSettings();
        await startSet();
      }catch(e){ alert('é–‹å§‹ã§ãã¾ã›ã‚“: '+(e.message||e)); }
    };

    document.getElementById('btn-review-thisset').onclick = async ()=>{
      const deck = (state.missedSetDeck||[]).map(q=>({ ...q }));
      await startSetCustom(deck);
    };

    // å¼±ç‚¹å¯¾ç­–ï¼ˆéå»7æ—¥ï¼‰
    document.getElementById('btn-weak').onclick=async ()=>{
      try{
        state.user=(document.getElementById('learner').value||'guest').trim()||'guest';
        document.getElementById('user-pill').textContent=`ğŸ‘¤ ${state.user}`;
        clearStageFHistoryCache();
        clearWrongQueueCache();
        state.totalPerSet=Math.max(3,Math.min(20,parseInt(document.getElementById('count').value||7,10)));
        state.endpoint=DEFAULT_ENDPOINT;
        state.setIndex=0; state.mode='weak'; state.qType=document.getElementById('qtype').value||'reorder';
        const unitSel=document.getElementById('unit-filter');
        if(unitSel){
          const selected=(unitSel.value||'').trim();
          if(BANK_REORDER.length || BANK_VOCAB_CHOICE.length || !state.unitFilter){
            state.unitFilter=selected;
          }
        }
        rememberSettings();
        await startSet();
      }catch(e){ alert('å¼±ç‚¹å¯¾ç­–ã‚’é–‹å§‹ã§ãã¾ã›ã‚“: '+(e.message||e)); }
    };
   
    // å…¥åŠ›æ¬„å¤‰æ›´ã§å³ä¿å­˜ï¼‹ã‚µã‚¸ã‚§ã‚¹ãƒˆæ›´æ–°
    document.getElementById('learner').addEventListener('change', (e)=>{
      const v=(e.target.value||'').trim(); if(!v) return;
      state.user=v; document.getElementById('user-pill').textContent=`ğŸ‘¤ ${v}`;
      clearStageFHistoryCache();
      clearWrongQueueCache();
      refreshStageFHistory().catch(()=>{});
      refreshWrongQueue().catch(()=>{});
      rememberSettings();
    });
    document.getElementById('unit-filter').addEventListener('change', (e)=>{
      const v=(e.target.value||'').trim();
      state.unitFilter=v;
      rememberSettings();
    });
    document.getElementById('qtype').addEventListener('change', async (e)=>{
      const v=(e.target.value||'').trim(); if(!v) return;
      state.qType=v;
      clearWrongQueueCache();
      refreshWrongQueue().catch(()=>{});
      state.unitFilter = getRememberedUnitFilter(state.qType);
      try{
        await ensureQuestions();
      }catch(err){
        console.error('ensureQuestions failed', err);
        alert('å•é¡Œã®èª­ã¿è¾¼ã¿ã«å¤±æ•—: '+(err.message||err));
      }
      renderUnitFilterOptions();
      const sel=document.getElementById('unit-filter');
      if(sel){ state.unitFilter=(sel.value||'').trim(); }
      rememberSettings();
    });

    document.getElementById('btn-check').onclick=checkAnswer; document.getElementById('btn-next').onclick=nextQuestion; document.getElementById('btn-undo').onclick=undo; document.getElementById('btn-clear').onclick=clearAnswer; document.getElementById('btn-clear-rewrite').onclick=()=>{ $('#rewrite-input').value=''; $('#rewrite-input').focus(); updateNextState(); }; document.getElementById('btn-hint').onclick=showHint;
    document.getElementById('rewrite-input').addEventListener('input', updateNextState);
    document.getElementById('btn-speak').onclick=()=>{
      const q=getCurrentQuestion();
      if(!q) return;
      const text = (Array.isArray(q.answers) && q.answers.length) ? q.answers[0] : q.en;
      const u=new SpeechSynthesisUtterance(text);
      u.lang='en-US';
      u.rate=1.0;
      speechSynthesis.cancel();
      speechSynthesis.speak(u);
    };

    // å®Œäº†ç”»é¢ã®é·ç§»
      document.getElementById('btn-nextset').onclick=async ()=>{
        try{
          state.setIndex++;
          if(state.mode==='review'){ state.mode='normal'; }
          clearStageFHistoryCache();
          clearWrongQueueCache();
          await startSet();
        }catch(e){
          alert('æ¬¡ã‚»ãƒƒãƒˆã‚’é–‹å§‹ã§ãã¾ã›ã‚“: '+(e.message||e));
        }
      };
    document.getElementById('btn-dashboard').onclick=()=>{ 
      try{ 
        const u = encodeURIComponent(state.user||'');
        window.location.href = `/admin?user=${u}`;
      }catch(e){ 
        alert('ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã¸ç§»å‹•ã§ãã¾ã›ã‚“: '+(e.message||e)); 
      } 
    };
    document.getElementById('btn-to-setup').onclick=()=>{ show('setup'); };

    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ï¼ˆEnterã§æ¡ç‚¹/æ¬¡ã¸ï¼‹iOSã§ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚’é–‰ã˜ã‚‹ï¼‰
    window.addEventListener('keydown',(e)=>{
      if(document.getElementById('quiz').style.display==='none') return;
      if(state.qType==='reorder'){
        if(e.key>='1' && e.key<='9'){ const idx=parseInt(e.key,10)-1; const chips=$$('#bank .chip'); const chip=chips[idx]; if(chip) placeChip(chip); }
        else if(e.key==='Backspace'){ e.preventDefault(); undo(); }
      } else if(state.qType==='vocab-choice'){
        if(e.key>='1' && e.key<='9'){
          const idx=parseInt(e.key,10)-1;
          const options=$$('#vocab-choice-options .choice-option');
          const target=options[idx];
          if(target){ target.click(); }
        }
      }
      if(e.key==='Enter'){
        e.preventDefault();
        if(!state.graded){ checkAnswer(); }
        else { nextQuestion(); }
        if(document.activeElement && document.activeElement.blur){ document.activeElement.blur(); }
      }
    });

    // åˆæœŸ
    loadRememberedSettings();
    ensureQuestions().catch(err=>{ console.error('ensureQuestions failed at init', err); });
    show('setup');
  </script>
</body>
</html>
