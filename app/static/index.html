<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>英語クイズ｜並べ替え＋単語＋書き換え</title>
  <style>
    :root{ --bg:#0f172a; --card:#111827; --muted:#94a3b8; --text:#e5e7eb; --border:#1f2937; --accent:#3b82f6; --warn:#ef4444 }
    *{ box-sizing:border-box }
    body{ margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif; -webkit-text-size-adjust:100% }
    header{ position:sticky; top:0; background:rgba(17,24,39,.9); backdrop-filter:saturate(150%) blur(6px); border-bottom:1px solid var(--border); z-index:10 }
    .container{ max-width:980px; margin:0 auto; padding:16px }
    .card{ background:var(--card); border:1px solid var(--border); border-radius:14px; padding:16px; margin:16px 0 }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
    .pill{ display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius:999px; border:1px solid #334155; background:#0b1220; color:#cbd5e1; font-size:12px }
    input,select{ background:#0b1220; color:#e5e7eb; border:1px solid #334155; border-radius:12px; padding:8px 10px }
    button{ border:1px solid #334155; background:#1f2937; color:#e5e7eb; border-radius:12px; padding:10px 14px; font-weight:700; cursor:pointer }
    button.primary{ background:var(--accent); border-color:var(--accent); color:white }
    button.warn{ background:var(--warn); border-color:var(--warn); color:white }
    button:disabled{ opacity:.5; cursor:not-allowed }
    .muted{ color:var(--muted) }
    .right{ margin-left:auto }
    .kbd{ font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; border:1px solid #334155; background:#0b1220; border-radius:6px; padding:2px 6px; color:#cbd5e1 }
    .target{ min-height:52px; padding:8px; background:#0b1220; border:2px dashed var(--accent); border-radius:12px; display:flex; gap:8px; flex-wrap:wrap }
    .bank{ display:flex; flex-wrap:wrap; gap:8px }
    .choice-grid{ display:grid; gap:10px; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); margin-top:10px }
    .choice-option{ border:1px solid #334155; background:#0b1220; border-radius:12px; padding:12px; text-align:left; cursor:pointer; transition:.15s; min-height:52px; font-size:15px; line-height:1.4 }
    .choice-option:hover{ transform:translateY(-1px) }
    .choice-option.selected{ border-color:var(--accent); background:rgba(59,130,246,.2); box-shadow:0 0 0 1px var(--accent) inset }
    .choice-option:focus-visible{ outline:2px solid var(--accent); outline-offset:2px }
    .chip{ background:#0b1220; border:1px solid #334155; border-radius:999px; padding:8px 12px; cursor:pointer; transition:.15s; user-select:none; min-height:44px }
    .chip:hover{ transform:translateY(-1px) }
    .chip.used{ opacity:.45; cursor:default }
    .ok{ color:#22c55e } .ng{ color:#ef4444 }
    .field{ display:flex; gap:8px; align-items:center }
    .input{ background:#0b1220; color:#e5e7eb; border:1px solid #334155; border-radius:10px; padding:10px 12px; min-width:240px }

    /* iOS Safari フォーカス時の自動ズーム抑止：16px以上に統一 */
    @supports (-webkit-touch-callout: none) {
      input, select, textarea { font-size:16px; line-height:1.2; }
      .input { font-size:16px; }
      #count { font-size:16px; }
    }
    input, select, textarea { min-height:44px; }

    /* --- モバイル最適化 & 操作ボタンの押しやすさ改善 --- */
    :root{ --tap:44px }
    body{ touch-action:manipulation }
    #vocab-input{ width:100% }
    #rewrite-input{ width:100%; min-height:72px; resize:vertical; }
    #target,#bank{ gap:10px }
    #bank{ max-height:40vh; overflow:auto; padding-bottom:6px }

    /* 操作ボタン配置：解答確認を最優先・大きく */
    #quiz .actions{ display:flex; flex-wrap:wrap; gap:10px; }
    #btn-check{ order:1; flex:1 1 100%; padding:14px 18px; font-size:18px; }
    #btn-next{ order:2; flex:1 1 48%; }
    #btn-undo, #btn-clear, #btn-speak{ order:3; flex:1 1 30%; min-width:120px }
    @media (min-width:820px){
      #btn-check{ flex-basis:60%; font-size:16px; }
      #btn-next{ flex-basis:auto; }
    }
  </style>
</head>
<body>
  <header>
    <div class="container row">
      <div>
        <h2 style="margin:0">英語クイズ <span class="muted">（並べ替え＋単語＋書き換え）</span></h2>
        <div class="muted" style="font-size:12px">外部JSON／復習モード／一問一採点／完了時は最小ペイロードをサーバ保存。</div>
      </div>
      <div class="right pill" id="user-pill">👤 ゲスト</div>
    </div>
  </header>

  <main class="container">
    <!-- 設定 -->
    <section class="card" id="setup">
      <div class="row">
        <label class="row" style="gap:6px"><span class="muted">学習者名</span><input id="learner" type="text" placeholder="taro" autocomplete="off" autocapitalize="off" list="user-suggestions" /></label><datalist id="user-suggestions"></datalist>
        <label class="row" style="gap:6px"><span class="muted">1セットの出題数</span><input id="count" type="number" min="3" max="20" value="7" style="width:80px"/></label>
        <label class="row" style="gap:6px"><span class="muted">出題タイプ</span>
          <select id="qtype">
            <option value="reorder">並べ替え（文法）</option>
            <option value="rewrite">書き換え（指定の形に）</option>
            <option value="vocab" selected>単語（意味→スペル）</option>
            <option value="vocab-choice">単語（英語→意味 選択式）</option>
          </select>
        </label>
        <label class="row" style="gap:6px"><span class="muted">ユニット</span>
          <select id="unit-filter">
            <option value="">全ユニット</option>
          </select>
        </label>
        <button class="primary" id="btn-start">▶ 学習スタート</button>
        <button id="btn-weak" title="過去7日の正答率が低い問題">🎯 弱点対策（過去7日）</button>
      </div>
      <div class="muted" style="margin-top:8px">
        並べ替え: <span class="kbd">1-9</span> で選択、<span class="kbd">Backspace</span> で戻す、<span class="kbd">Enter</span> で採点/次へ。<br>
        書き換え: 指示に従って英文を入力（句読点も忘れずに）。<br>
        単語: 入力欄にスペルを入力（英字・大文字小文字は不問）。
        単語（選択式）: 表示される英単語に合う日本語の意味を選択。
      </div>
    </section>

    <!-- クイズ（共通ヘッダ） -->
    <section class="card" id="quiz" style="display:none">
      <div class="row">
          <span class="pill" id="status">Q 1/7</span>
          <span class="pill">正解: <b id="stat-correct">0</b></span>
          <span class="pill">誤答: <b id="stat-wrong">0</b></span>
          <span class="pill" id="stat-streak">連続正解: --</span>
          <span class="pill" id="stat-accuracy">正解率: --</span>
          <span class="pill" id="stat-stage">ステージ: --</span>
          <span class="pill" id="stat-bucket">バケット: --</span>
          <span class="pill right" id="timer">⏱ 00:00</span>
      </div>
      <div id="prompt" class="muted">（日本語プロンプト）</div>

      <!-- 並べ替えUI -->
      <div id="ui-reorder">
        <div id="target" class="target" aria-label="答えのエリア"></div>
        <div id="bank" class="bank" aria-label="単語のエリア"></div>
      </div>

      <!-- 単語UI -->
      <div id="ui-vocab" style="display:none; margin-top:10px">
        <div class="field">
          <input id="vocab-input" class="input" type="text" placeholder="スペルを入力（例: interesting）" autocomplete="off" autocapitalize="off" autocorrect="off" inputmode="latin" />
          <button id="btn-clear-vocab">🧹 クリア</button>
        </div>
        <div class="muted" id="vocab-tip" style="margin-top:6px"></div>
      </div>

      <!-- 単語選択UI -->
      <div id="ui-vocab-choice" style="display:none; margin-top:10px">
        <div class="muted" id="vocab-choice-tip" style="margin-bottom:6px"></div>
        <div id="vocab-choice-options" class="choice-grid" role="radiogroup" aria-label="日本語の意味を選択"></div>
      </div>

      <!-- 書き換えUI -->
      <div id="ui-rewrite" style="display:none; margin-top:10px">
        <div class="muted" id="rewrite-extra" style="margin-bottom:6px"></div>
        <div class="field">
          <textarea id="rewrite-input" class="input" placeholder="指示に合わせて英文を書き換えてください" autocapitalize="off" autocorrect="off" spellcheck="false"></textarea>
          <button id="btn-clear-rewrite">🧹 クリア</button>
        </div>
        <div class="muted" id="rewrite-tip" style="margin-top:6px"></div>
      </div>

      <div class="row actions" style="margin-top:10px">
        <button class="primary" id="btn-check">答え合わせ <span class="kbd">Enter</span></button>
        <button id="btn-next" disabled>次の問題 ▶</button>
        <button id="btn-undo">↩ ひとつ戻す</button>
        <button id="btn-clear">🧹 クリア</button>
        <button id="btn-speak">🔊 正解文/単語</button>
        <button id="btn-hint">💡 ヒント</button>
      </div>
      <div id="explain" class="muted" style="min-height:1.6em"></div>
    </section>

    <!-- セット終了 -->
    <section class="card" id="finished" style="display:none">
      <h3 style="margin:0 0 8px">セット完了！</h3>
      <p id="summary" class="muted"></p>
      <p id="save-status" class="muted">結果送信: 待機中…</p>
      <div class="row">
        <button class="primary" id="btn-review-thisset" disabled>❗このセットのまちがいで復習</button>
        <button class="primary" id="btn-nextset">▶ 次の問題群（次セット）</button>
        <button id="btn-dashboard">📊 成績を見る</button>
        <button class="warn right" id="btn-to-setup">設定に戻る</button>
      </div>
    </section>
  </main>

  <script src="fallback_extras.js"></script>
  <script src="stage_priority.js"></script>
  <script>
    /********** 設定 **********/
    const SUBJECT = 'english';
    const QUESTIONS_URL = `/data/${SUBJECT}/questions.json`; // Flaskで配信
    const DEFAULT_ENDPOINT = "/api/results";
    const LEVEL_ORDER = ['Lv1','Lv2','Lv3'];
    const DEFAULT_LEVEL = LEVEL_ORDER[0];

    // 設定の記憶用キー
    const REMEMBER_USER_KEY = 'quiz:lastUser';
    const REMEMBER_QTYPE_KEY = 'quiz:lastQType';
    const REMEMBER_UNIT_KEY = 'quiz:lastUnitFilter';
    const USER_SUGGEST_KEY = 'quiz:userList';

    /********** 問題ロード **********/
    let BANK_REORDER = [];
    let BANK_VOCAB_INPUT = [];
    let BANK_VOCAB_CHOICE = [];
    let BANK_REWRITE = [];

    const toAnswerList = (value)=>{
      if(Array.isArray(value)){
        return value
          .map(v=>typeof v==='string'? v.trim(): '')
          .filter(v=>v);
      }
      if(typeof value==='string'){
        const trimmed = value.trim();
        return trimmed? [trimmed] : [];
      }
      return [];
    };

    const collectAnswerSet = (item)=>{
      const primary = toAnswerList(item.en);
      const extras = [];
      [item.accept, item.accepts, item.answers, item.alternates, item.variants]
        .forEach(src=>{ toAnswerList(src).forEach(ans=>extras.push(ans)); });
      const merged = [...primary, ...extras];
      if(!merged.length && typeof item.en==='string'){
        const fallback = item.en.trim();
        if(fallback) merged.push(fallback);
      }
      const unique = [];
      merged.forEach(ans=>{ if(!unique.includes(ans)) unique.push(ans); });
      return unique;
    };

    const caseAware = (match, replacement)=>{
      if(!match) return replacement;
      if(match === match.toUpperCase()) return replacement.toUpperCase();
      if(match[0] === match[0].toUpperCase()){
        return replacement.charAt(0).toUpperCase() + replacement.slice(1);
      }
      return replacement.toLowerCase();
    };

    const replaceAmNot = text=>{
      const regex = /\b(I)\s+am not\b/gi;
      let changed = false;
      const result = text.replace(regex, (match)=>{
        changed = true;
        if(match === match.toUpperCase()) return "I'M NOT";
        const base = match[0]===match[0].toUpperCase()? "I'm not" : "i'm not";
        return caseAware(match, base);
      });
      return changed && result!==text ? result : null;
    };

    const replaceSimple = (text, pattern, contracted)=>{
      let changed = false;
      const result = text.replace(pattern, match=>{
        changed = true;
        return caseAware(match, contracted);
      });
      return changed && result!==text ? result : null;
    };

    const expandRewriteVariants = list=>{
      const queue = [];
      const seen = new Set();
      const push = value=>{
        if(typeof value !== 'string') return;
        const trimmed = value.trim();
        if(!trimmed || seen.has(trimmed)) return;
        seen.add(trimmed);
        queue.push(trimmed);
      };
      list.forEach(push);
      const variants = [];
      const replacers = [
        text=>replaceAmNot(text),
        text=>replaceSimple(text, /\bare not\b/gi, "aren't"),
        text=>replaceSimple(text, /\bis not\b/gi, "isn't"),
        text=>replaceSimple(text, /\bwas not\b/gi, "wasn't"),
        text=>replaceSimple(text, /\bwere not\b/gi, "weren't"),
        text=>replaceSimple(text, /\bdo not\b/gi, "don't"),
        text=>replaceSimple(text, /\bdoes not\b/gi, "doesn't"),
        text=>replaceSimple(text, /\bdid not\b/gi, "didn't"),
        text=>replaceSimple(text, /\bhas not\b/gi, "hasn't"),
        text=>replaceSimple(text, /\bhave not\b/gi, "haven't"),
        text=>replaceSimple(text, /\bhad not\b/gi, "hadn't"),
        text=>replaceSimple(text, /\bwill not\b/gi, "won't"),
        text=>replaceSimple(text, /\bwould not\b/gi, "wouldn't"),
        text=>replaceSimple(text, /\bshould not\b/gi, "shouldn't"),
        text=>replaceSimple(text, /\bmust not\b/gi, "mustn't"),
        text=>replaceSimple(text, /\bneed not\b/gi, "needn't"),
        text=>replaceSimple(text, /\bcould not\b/gi, "couldn't"),
        text=>replaceSimple(text, /\bcannot\b/gi, "can't"),
        text=>replaceSimple(text, /\bcan not\b/gi, "can't"),
        text=>replaceSimple(text, /\bmight not\b/gi, "mightn't")
      ];
      while(queue.length){
        const current = queue.shift();
        variants.push(current);
        replacers.forEach(fn=>{
          const next = fn(current);
          if(next){ push(next); }
        });
      }
      return variants;
    };

    const normalizeLevel = (value)=>{
      const str = (value==null ? '' : String(value)).trim();
      if(LEVEL_ORDER.includes(str)) return str;
      const match = str.match(/([1-3])/);
      if(match){
        const candidate = `Lv${match[1]}`;
        if(LEVEL_ORDER.includes(candidate)) return candidate;
      }
      return DEFAULT_LEVEL;
    };

    const levelIndex = (value)=>{
      const lvl = normalizeLevel(value);
      const idx = LEVEL_ORDER.indexOf(lvl);
      return idx === -1 ? LEVEL_ORDER.length : idx;
    };

    const questionKey = (question)=>{
      if(!question) return '';
      if(question.id != null) return `id:${question.id}`;
      const type = question.type || '';
      const en = question.en || '';
      const jp = question.jp || '';
      return `${type}:${en}__${jp}`;
    };

    const buildQuestion = (item, type)=>{
      let answers = collectAnswerSet(item);
      const primary = answers[0] || (typeof item.en==='string'? item.en.trim(): '');
      if(type==='rewrite'){
        answers = expandRewriteVariants(answers);
      }
      const base = {
        type,
        id: item.id||null,
        unit: item.unit||null,
        jp: item.jp,
        en: primary,
        answers,
        tip: item.tip||'',
        explain: item.explain||'',
        level: normalizeLevel(item.level)
      };
      if(type==='reorder'){
        base.chunks = item.chunks;
        base.wrong = item.wrong||[];
      } else if(type==='vocab' || type==='vocab-choice'){
        base.pos = item.pos||'';
        if(type==='vocab-choice' && Array.isArray(item.choices)){
          const normalized = [];
          item.choices.forEach(choice=>{
            if(choice==null) return;
            if(typeof choice === 'string'){
              const text = choice.trim();
              if(!text) return;
              normalized.push({ text, correct: false });
              return;
            }
            if(typeof choice === 'object'){
              const rawText = typeof choice.text === 'string'
                ? choice.text
                : (typeof choice.value === 'string' ? choice.value : '');
              const text = rawText.trim();
              if(!text) return;
              normalized.push({ text, correct: choice.correct === true });
            }
          });
          if(normalized.length){
            base.choices = normalized;
          }
        }
      } else if(type==='rewrite'){
        base.source = item.source || '';
        base.task = item.task || '';
        base.note = item.note || '';
      }
      return base;
    };
    async function ensureQuestions(){
      if (BANK_REORDER.length || BANK_VOCAB_INPUT.length || BANK_VOCAB_CHOICE.length || BANK_REWRITE.length){ renderUnitFilterOptions(); return; }
      const res = await fetch(QUESTIONS_URL, { cache: "no-store" });
      if (!res.ok) throw new Error("質問ファイルの読み込みに失敗: " + res.status);
      const data = await res.json();
      // 互換: 旧形式 questions は並べ替え扱い
      const rawVocabInput = Array.isArray(data.vocabInput)
        ? data.vocabInput
        : Array.isArray(data.vocab)
          ? data.vocab.filter(item=>!(Array.isArray(item.choices) && item.choices.length>0))
          : [];
      const rawVocabChoice = Array.isArray(data.vocabChoice)
        ? data.vocabChoice
        : Array.isArray(data.vocab)
          ? data.vocab.filter(item=>Array.isArray(item.choices) && item.choices.length>0)
          : [];
      BANK_REORDER = (data.questions||data.reorder||[]).map(q=>buildQuestion(q, 'reorder'));
      BANK_VOCAB_INPUT = rawVocabInput.map(v=>buildQuestion(v, 'vocab'));
      BANK_VOCAB_CHOICE = rawVocabChoice.map(v=>buildQuestion(v, 'vocab-choice'));
      BANK_REWRITE = (data.rewrite||[]).map(w=>buildQuestion(w, 'rewrite'));
      renderUnitFilterOptions();
    }

    /********** 状態 **********/
    const state = {
      user:'guest', endpoint: DEFAULT_ENDPOINT,
      qType:'reorder',
      unitFilter:'',
      levelMax: DEFAULT_LEVEL,
      totalPerSet:7, order:[], setIndex:0,
      qIndex:0, correct:0, wrong:0,
      startedAt:null, seconds:0, timerId:null,
      answered:[],   // サーバ送信用（通常モード）
      reviewed:[],   // サーバ送信用（復習モード）
      graded:false,  // 一問一採点
      mode:'normal',
      reviewStrategy:'all', // 'all' | 'recent'
      weakWindowDays:7,      // 過去◯日を対象
      missedSetDeck: [],   // このセットで間違えた問題のデッキ
      choiceSelection: null,
      fallbackExtras: [],  // レベル不足を補う追加問題（このセット限定）
      fallbackStageOverrides: new Map(), // 補充問題のステージ上書き（問題キー -> ステージ）
    };

    const $ = s=>document.querySelector(s);
    const $$ = s=>Array.from(document.querySelectorAll(s));

    const typedInputElement = ()=>{
      if(state.qType==='vocab') return $('#vocab-input');
      if(state.qType==='rewrite') return $('#rewrite-input');
      return null;
    };

    /********** ユーティリティ **********/
    const fmtTime = s=>{ const m=String(Math.floor(s/60)).padStart(2,'0'); const r=String(s%60).padStart(2,'0'); return `${m}:${r}` };
    const shuffle = arr=>arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);
    const NBSP = String.fromCharCode(160);
    const normalizeDigits = s=> (s==null ? '' : String(s).replace(/[‘’‚‛‹›`´]/g,"'").replace(/[“”„‟«»]/g,'"').replace(/[０-９]/g, ch=> String.fromCharCode(ch.charCodeAt(0)-0xFEE0)));
    const normalizeSpaces = s=> normalizeDigits(s).replace(new RegExp(`[${NBSP}\\s]+`,'g'),' ').trim();
    const normalizeEndPunc = (s, keep=false)=> keep ? s.replace(/\s+([.,!?])/g, "$1") : s.replace(/\s*[.,!?]$/,'');
    const normalizeWord = s=> normalizeSpaces(s).toLowerCase();
    const normalizeUnit = u=> (u===null || u===undefined ? '' : String(u).trim());
    const HARD_STREAK = 2;
    const nowISO = ()=> new Date().toISOString();

    async function postJSON(url, data, timeoutMs=6000){
      const ctrl = new AbortController();
      const t = setTimeout(()=>ctrl.abort(), timeoutMs);
      try{
        const res = await fetch(url,{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(data), signal: ctrl.signal});
        clearTimeout(t);
        return {ok: res.ok, status: res.status};
      }catch(e){ clearTimeout(t); return {ok:false, error:String(e)}; }
    }

    async function startSetCustom(customDeck){
      try{ await ensureQuestions(); }catch(e){ alert(e.message||e); return; }
      if(!customDeck || !customDeck.length){ alert('このセットの間違いはありません。'); return; }

      // セット初期化
      state.qIndex=0; state.correct=0; state.wrong=0; state.answered=[]; state.reviewed=[]; state.graded=false; state.choiceSelection=null;
      $('#stat-correct').textContent='0'; $('#stat-wrong').textContent='0';

      // レビュー用デッキに流し込む（既存ロジック流用）
      window.__REVIEW_DECK__ = customDeck.map(q=>({ ...q }));
      state.order = [...window.__REVIEW_DECK__.keys()].map(i=>({idx:i, bucket:null, streak:0}));
      state.mode = 'review';
      // 表示UIを合わせる（並べ替え/単語）
      state.qType = (window.__REVIEW_DECK__[0]?.type) || state.qType;

      show('quiz'); startTimer(); renderQuestion();
    }

    /********** 設定の記憶（ユーザー名・出題タイプ） **********/
    function populateUserSuggestions(){
      const dl=document.getElementById('user-suggestions'); if(!dl) return;
      const list=JSON.parse(localStorage.getItem(USER_SUGGEST_KEY)||'[]');
      dl.innerHTML='';
      list.forEach(name=>{ const opt=document.createElement('option'); opt.value=name; dl.appendChild(opt); });
    }

    function readRememberedUnitMap(){
      try{
        const raw = localStorage.getItem(REMEMBER_UNIT_KEY);
        if(!raw) return {};
        const data = JSON.parse(raw);
        return (data && typeof data === 'object') ? data : {};
      }catch(e){
        return {};
      }
    }
    function writeRememberedUnitMap(map){
      try{
        localStorage.setItem(REMEMBER_UNIT_KEY, JSON.stringify(map));
      }catch(e){
        // ignore
      }
    }
    function getRememberedUnitFilter(qType){
      const map = readRememberedUnitMap();
      const val = map && typeof map === 'object' ? map[qType] : '';
      return (typeof val === 'string') ? val : '';
    }
    function rememberUnitFilter(qType, value){
      const map = readRememberedUnitMap();
      const v = (value || '').trim();
      if(v){ map[qType] = v; }
      else { delete map[qType]; }
      writeRememberedUnitMap(map);
    }

    function stageFStorageKey(){
      const user = (state.user || '').trim() || 'guest';
      return `quiz:${user}:stageF:${SUBJECT}`;
    }

    let cachedStageFKey = null;
    let cachedStageFSet = null;

    function getStageFHistory(){
      const key = stageFStorageKey();
      if(cachedStageFKey === key && cachedStageFSet instanceof Set){
        return cachedStageFSet;
      }
      let parsed = [];
      try{
        const raw = localStorage.getItem(key);
        if(raw){
          const data = JSON.parse(raw);
          if(Array.isArray(data)){
            parsed = data
              .map(v => (typeof v === 'string' ? v.trim() : ''))
              .filter(v => v);
          }
        }
      }catch(_err){
        parsed = [];
      }
      const set = new Set(parsed);
      cachedStageFKey = key;
      cachedStageFSet = set;
      return set;
    }

    function saveStageFHistory(set){
      const key = stageFStorageKey();
      try{
        localStorage.setItem(key, JSON.stringify(Array.from(set)));
      }catch(_err){
        // ignore write errors
      }
      cachedStageFKey = key;
      cachedStageFSet = new Set(set);
    }

    function rememberStageFKeys(keys){
      if(!Array.isArray(keys) || keys.length === 0) return;
      const set = getStageFHistory();
      let changed = false;
      keys.forEach(key => {
        if(typeof key === 'string' && key && !set.has(key)){
          set.add(key);
          changed = true;
        }
      });
      if(changed){
        saveStageFHistory(set);
      }
    }

    function clearStageFHistoryCache(){
      cachedStageFKey = null;
      cachedStageFSet = null;
    }

    function isEligibleByLevel(question, maxLevelIdx, stageFSet){
      if(!question) return false;
      if(!Number.isFinite(maxLevelIdx)) return true;
      const lvlIdx = levelIndex(question.level);
      if(lvlIdx <= maxLevelIdx) return true;
      if(!(stageFSet instanceof Set)) return false;
      const key = questionKey(question);
      return key ? stageFSet.has(key) : false;
    }

    function renderUnitFilterOptions(){
      const sel = document.getElementById('unit-filter');
      if(!sel) return;
      const maxLevelIdx = levelIndex(state.levelMax);
      const stageFHistory = getStageFHistory();
      const deckArr = deckByType(state.qType).filter(q=> isEligibleByLevel(q, maxLevelIdx, stageFHistory));
      const units = Array.from(new Set(deckArr.map(q=>normalizeUnit(q.unit)).filter(u=>u))).sort((a,b)=>a.localeCompare(b, 'ja', { numeric:true, sensitivity:'base' }));
      sel.innerHTML='';
      const optAll=document.createElement('option'); optAll.value=''; optAll.textContent='全ユニット'; sel.appendChild(optAll);
      units.forEach(u=>{ const opt=document.createElement('option'); opt.value=u; opt.textContent=u; sel.appendChild(opt); });
      if(deckArr.length===0){
        sel.value='';
        sel.disabled=true;
        if(state.unitFilter){
          state.unitFilter='';
          rememberUnitFilter(state.qType, '');
        }
        return;
      }
      sel.disabled=false;
      if(state.unitFilter && !units.includes(state.unitFilter)){
        state.unitFilter='';
        rememberUnitFilter(state.qType, '');
      }
      sel.value = state.unitFilter || '';
    }
    function loadRememberedSettings(){
      const u=(localStorage.getItem(REMEMBER_USER_KEY)||'').trim();
      if(u){ state.user=u; const inp=document.getElementById('learner'); if(inp) inp.value=u; const pill=document.getElementById('user-pill'); if(pill) pill.textContent=`👤 ${u}`; }
      const qt=(localStorage.getItem(REMEMBER_QTYPE_KEY)||'').trim();
      const qs=document.getElementById('qtype');
      if(qt){ state.qType=qt; if(qs) qs.value=qt; }
      state.levelMax = DEFAULT_LEVEL;
      state.unitFilter = getRememberedUnitFilter(state.qType);
      const unitSel = document.getElementById('unit-filter');
      if(unitSel){ unitSel.value = state.unitFilter || ''; }
      state.endpoint=DEFAULT_ENDPOINT;
      clearStageFHistoryCache();
      populateUserSuggestions();
    }
    function rememberSettings(){
      if(state.user) localStorage.setItem(REMEMBER_USER_KEY, state.user);
      if(state.qType) localStorage.setItem(REMEMBER_QTYPE_KEY, state.qType);
      rememberUnitFilter(state.qType, state.unitFilter||'');
      const raw=JSON.parse(localStorage.getItem(USER_SUGGEST_KEY)||'[]');
      const list=Array.isArray(raw)? raw.slice(0) : [];
      if(state.user){
        const i=list.indexOf(state.user); if(i!==-1) list.splice(i,1);
        list.unshift(state.user);
        if(list.length>20) list.length=20;
        localStorage.setItem(USER_SUGGEST_KEY, JSON.stringify(list));
      }
      populateUserSuggestions();
    }

    /********** ストレージ（ローカル） **********/
    const storeKey=(u)=>`quiz:${u}`;
    const wrongKey=(u,t)=>`quiz:${u}:wrong:${t}`;
    function getHistory(){ const raw=JSON.parse(localStorage.getItem(storeKey(state.user))||'{}'); return raw.history||[]; }
    function pushHistory(session){ const raw=JSON.parse(localStorage.getItem(storeKey(state.user))||'{}'); raw.history=raw.history||[]; raw.history.unshift(session); localStorage.setItem(storeKey(state.user), JSON.stringify(raw)); }
    function getWrongQueue(){ return JSON.parse(localStorage.getItem(wrongKey(state.user, state.qType))||'[]'); }
    function setWrongQueue(list){ localStorage.setItem(wrongKey(state.user, state.qType), JSON.stringify(list.slice(0,150))); }
    function addWrongLocal(item){ const q=getWrongQueue(); const key=item.id?`id:${item.id}`:`${item.en}__${item.jp}`; if(!q.some(x=>x.key===key)){ q.unshift({...item, key}); setWrongQueue(q); } }
    function removeFromWrongIfMatched(rec){ const q=getWrongQueue(); const key=rec.id?`id:${rec.id}`:null; let idx=-1; if(key){ idx=q.findIndex(x=>x.key===key); } if(idx===-1){ idx=q.findIndex(x=>x.en===rec.en && x.jp===rec.jp); } if(idx>-1){ q.splice(idx,1); setWrongQueue(q); } }

    /********** 画面切替 **********/
    function show(id){ ['setup','quiz','finished'].forEach(sec=>{ const el=$(`#${sec}`); if(!el) return; el.style.display = (sec===id)?'block':'none'; }); }

    /********** デッキ取得 **********/
    function deckByType(type){
      if(type==='reorder') return BANK_REORDER;
      if(type==='vocab') return BANK_VOCAB_INPUT;
      if(type==='vocab-choice') return BANK_VOCAB_CHOICE;
      if(type==='rewrite') return BANK_REWRITE;
      return [];
    }
    function deck(options){
      const opts = options || {};
      const includeExtras = opts.includeExtras !== false;
      const all = deckByType(state.qType);
      if(state.mode==='review') return all;
      const maxLevelIdx = levelIndex(state.levelMax);
      const stageFHistory = getStageFHistory();
      let filtered = all.filter(q=> isEligibleByLevel(q, maxLevelIdx, stageFHistory));
      const shouldFilterByUnit = state.mode==='normal' || state.mode==='weak';
      const unit = shouldFilterByUnit ? (state.unitFilter || '') : '';
      if(unit){
        filtered = filtered.filter(q=> normalizeUnit(q.unit) === unit);
      }
      if(!includeExtras) return filtered;
      const extras = Array.isArray(state.fallbackExtras) ? state.fallbackExtras : [];
      if(!extras.length) return filtered;
      if(!unit) return filtered.concat(extras);
      const extrasForUnit = extras.filter(q=> normalizeUnit(q.unit) === unit);
      if(!extrasForUnit.length) return filtered;
      return filtered.concat(extrasForUnit);
    }

    const STAGE_PRIORITY = ['A','B','C','D','E'];

    const stagePriorityApi = (typeof window !== 'undefined' && window.__stagePriority)
      ? window.__stagePriority
      : ((typeof globalThis !== 'undefined' && globalThis.__stagePriority)
        ? globalThis.__stagePriority
        : {});
    const shouldPrioritizeStagePromotion = typeof stagePriorityApi.shouldPrioritizeStagePromotion === 'function'
      ? stagePriorityApi.shouldPrioritizeStagePromotion
      : (stage, nextDue, nowMs) => {
          const normalizedStage = typeof stage === 'string' ? stage.trim().toUpperCase() : '';
          if(!STAGE_PRIORITY.includes(normalizedStage) || normalizedStage === 'A'){
            return false;
          }
          if(!(nextDue instanceof Date)){
            return false;
          }
          const effectiveNow = Number.isFinite(nowMs) ? nowMs : Date.now();
          return nextDue.getTime() <= effectiveNow;
        };

    function parseIsoDate(value){
      if(!value) return null;
      const date = new Date(value);
      return Number.isNaN(date.getTime()) ? null : date;
    }

    function normalizeStage(value){
      if(typeof value !== 'string') return 'F';
      const upper = value.trim().toUpperCase();
      if(STAGE_PRIORITY.includes(upper) || upper === 'F') return upper;
      return 'F';
    }

    function willStageUpOnSuccess(stage, nextDue, now){
      const normalizedStage = typeof stage === 'string' ? stage.trim().toUpperCase() : '';
      const effectiveNow = Number.isFinite(now) ? now : Date.now();
      const nextDueValue = nextDue instanceof Date ? nextDue : null;
      return !!shouldPrioritizeStagePromotion(normalizedStage, nextDueValue, effectiveNow);
    }

    async function fetchStatsForEntries(entries, user){
      const trimmedUser = (user || '').trim();
      const ids = entries
        .filter(entry => entry.id)
        .map(entry => entry.id);
      if(!trimmedUser || !ids.length){
        return entries.map(() => null);
      }
      try{
        const res = await fetch('/api/stats/bulk', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user: trimmedUser,
            subject: SUBJECT,
            ids,
          }),
        });
        if(!res.ok){
          throw new Error(`bulk stats failed with ${res.status}`);
        }
        const data = await res.json();
        const list = Array.isArray(data.results) ? data.results : [];
        const map = new Map();
        list.forEach(item => {
          if(item && item.id != null){
            map.set(String(item.id), item);
          }
        });
        return entries.map(entry => {
          if(!entry.id) return null;
          return map.get(entry.id) || null;
        });
      }catch(err){
        console.warn('英語の成績データ取得に失敗しました', err);
        return entries.map(() => null);
      }
    }

    /********** セット準備 **********/
    async function buildOrderFromBank(){
      const blockedFallbackKeys = new Set();
      const MAX_ATTEMPTS = 4;
      let forcedExtraDeficit = 0;
      let lastOrder = [];

      for(let attempt=0; attempt<MAX_ATTEMPTS; attempt++){
        const baseDeck = deck({ includeExtras: false });
        state.fallbackExtras = [];
        state.fallbackStageOverrides = new Map();
        const fallbackStageOverrides = state.fallbackStageOverrides;
        const desired = state.totalPerSet;
        const deckArrBase = baseDeck.slice();
        const baseDeckCount = deckArrBase.length;
        const appendFallbackExtras = (typeof window !== 'undefined'
          && window
          && window.__quizFallbackExtras
          && typeof window.__quizFallbackExtras.appendFallbackExtras === 'function')
            ? window.__quizFallbackExtras.appendFallbackExtras
            : (extrasArr, prioritizedList, othersList, totalNeeded, baseCountValue)=>{
                if(!Array.isArray(extrasArr)) return extrasArr;
                const total = Number.isFinite(totalNeeded) ? Math.max(0, Math.floor(totalNeeded)) : 0;
                if(total === 0) return extrasArr;
                const base = Number.isFinite(baseCountValue)
                  ? Math.min(Math.max(0, Math.floor(baseCountValue)), total)
                  : 0;
                const limit = Math.max(0, total - base);
                if(limit === 0) return extrasArr;
                const pushLimited = (list)=>{
                  if(!Array.isArray(list) || !list.length) return;
                  const remaining = limit - extrasArr.length;
                  if(remaining <= 0) return;
                  extrasArr.push(...list.slice(0, remaining));
                };
                pushLimited(prioritizedList);
                pushLimited(othersList);
                return extrasArr;
              };

        const shouldFilterByUnit = state.mode==='normal' || state.mode==='weak';
        const unitFilter = shouldFilterByUnit ? (state.unitFilter || '') : '';
        const maxLevelIdx = levelIndex(state.levelMax);

        const allDeck = deckByType(state.qType);
        const stageFHistory = getStageFHistory();

        const toKey = (item)=>{
          if(!item) return '';
          try{
            return questionKey(item);
          }catch(_err){
            if(item.id != null) return `id:${item.id}`;
            const en = item.en || '';
            const jp = item.jp || '';
            return `${en}__${jp}`;
          }
        };
        const toLegacyKey = (item)=>{
          if(!item) return '';
          if(item.id != null) return `id:${item.id}`;
          const en = item.en || '';
          const jp = item.jp || '';
          return `${en}__${jp}`;
        };

        const seenKeys = new Set(deckArrBase.map(q=>toKey(q)).filter(Boolean));
        blockedFallbackKeys.forEach(key=>{
          if(key) seenKeys.add(key);
        });

        const baseShortage = Math.max(0, desired - baseDeckCount);
        const extrasLimit = baseShortage + Math.max(0, forcedExtraDeficit);

        if(extrasLimit > 0){
          const wrongSet = new Set();
          (getWrongQueue() || []).forEach(item=>{
            if(!item) return;
            if(item.key) wrongSet.add(item.key);
            const primary = toKey(item);
            if(primary) wrongSet.add(primary);
            const legacy = toLegacyKey(item);
            if(legacy) wrongSet.add(legacy);
          });
          const extras = [];
          const pickFromLevel = (levelIdx)=>{
            const candidates = allDeck.filter(q=> levelIndex(q.level) === levelIdx);
            const filteredCandidates = unitFilter
              ? candidates.filter(q=> normalizeUnit(q.unit) === unitFilter)
              : candidates;
            const prioritized = [];
            const others = [];
            for(const q of filteredCandidates){
              const key = toKey(q);
              if(!key) continue;
              if(seenKeys.has(key)) continue;
              seenKeys.add(key);
              const legacyKey = toLegacyKey(q);
              if(wrongSet.has(key) || (legacyKey && wrongSet.has(legacyKey))) prioritized.push(q);
              else others.push(q);
            }
            const prioritizedShuffled = prioritized.length ? shuffle(prioritized) : [];
            const othersShuffled = others.length ? shuffle(others) : [];
            const desiredTotalForExtras = baseDeckCount + extrasLimit;
            appendFallbackExtras(extras, prioritizedShuffled, othersShuffled, desiredTotalForExtras, baseDeckCount);
          };

          for(let levelIdx = maxLevelIdx + 1; levelIdx < LEVEL_ORDER.length; levelIdx++){
            pickFromLevel(levelIdx);
            if(baseDeckCount + extras.length >= baseDeckCount + extrasLimit) break;
          }

          state.fallbackExtras = extras;
          extras.forEach(q=>{
            const key = toKey(q);
            if(!key) return;
            fallbackStageOverrides.set(key, 'F');
          });
        }

        const currentExtraKeys = new Set((state.fallbackExtras || []).map(item=>toKey(item)).filter(Boolean));

        const deckArr = deck({ includeExtras: true });
        const targetCount = Math.min(desired, deckArr.length);

        const dueByStage = new Map(STAGE_PRIORITY.map(stage=>[stage, []]));
        const stageFPool = [];
        const levelBuckets = new Map();
        const stageByIndex = new Map();

        const entries = deckArr.map((q, idx)=>({
          idx,
          id: q && q.id ? String(q.id) : null,
        }));

        const stats = await fetchStatsForEntries(entries, state.user);

        const now = Date.now();

        const pushLevelCandidate = (levelIdx, payload)=>{
          if(!Number.isFinite(levelIdx)) return;
          let bucket = levelBuckets.get(levelIdx);
          if(!bucket){
            bucket = [];
            levelBuckets.set(levelIdx, bucket);
          }
          bucket.push(payload);
        };

        for(let i=0;i<deckArr.length;i++){
          const question = deckArr[i];
          const levelIdx = levelIndex(question && question.level);
          const s = stats[i];
          if(!s || typeof s !== 'object'){
            stageByIndex.set(i, 'F');
            stageFPool.push({idx:i, streak:0});
            pushLevelCandidate(levelIdx, { idx:i, stage:'F', streak:0, nextDue:null, rand:Math.random() });
            continue;
          }

          const qKey = toKey(question);
          const hasFallbackOverride = qKey && fallbackStageOverrides.has(qKey);
          const hasHistoryOverride = qKey && stageFHistory.has(qKey);
          const actualStage = normalizeStage(s.stage);
          const overrideStage = hasFallbackOverride
            ? normalizeStage(fallbackStageOverrides.get(qKey))
            : (hasHistoryOverride ? 'F' : null);
          const stage = overrideStage || actualStage;
          stageByIndex.set(i, stage);
          const rawStreak = Number(s.streak);
          const baseStreak = Number.isFinite(rawStreak) ? rawStreak : 0;
          const streak = hasFallbackOverride ? 0 : baseStreak;
          const nextDue = parseIsoDate(s.nextDueAt);
          const nextDueMs = nextDue instanceof Date ? nextDue.getTime() : null;
          const isTrackedStageForWait = STAGE_PRIORITY.includes(actualStage);
          const isWaiting = !hasHistoryOverride && isTrackedStageForWait && nextDueMs != null && nextDueMs > now;
          const willPromote = !overrideStage && willStageUpOnSuccess(actualStage, nextDue, now);
          if(isWaiting){
            if(qKey && currentExtraKeys.has(qKey)){
              blockedFallbackKeys.add(qKey);
            }
            continue;
          }
          const payload = { idx:i, stage, actualStage, streak, nextDue, rand:Math.random() };
          pushLevelCandidate(levelIdx, payload);
          if(willPromote){
            const arr = dueByStage.get(actualStage);
            if(arr){
              arr.push(payload);
              continue;
            }
          }

          if(stage === 'F'){
            stageFPool.push({ idx:i, streak });
          }else if(!STAGE_PRIORITY.includes(stage)){
            stageFPool.push({ idx:i, streak });
          }
        }

        const n = targetCount;

        const order = [];
        const chosen = new Set();

        const dueCandidateCount = STAGE_PRIORITY.reduce((acc, stage)=>{
          const arr = dueByStage.get(stage);
          return acc + (Array.isArray(arr) ? arr.length : 0);
        }, 0);
        const effectiveStageFCount = Math.max(0, stageFPool.length - dueCandidateCount);
        const baseStagePriorityQuota = typeof determineStagePriorityQuota === 'function'
          ? determineStagePriorityQuota(n, effectiveStageFCount)
          : Math.max(0, n - Math.min(effectiveStageFCount, n));
        let stagePriorityQuota = baseStagePriorityQuota;
        if(stagePriorityQuota < n && dueCandidateCount > 0){
          const minimumQuota = Math.min(
            n,
            Math.max(1, Math.min(dueCandidateCount, Math.ceil(n / 3)))
          );
          if(stagePriorityQuota < minimumQuota){
            stagePriorityQuota = minimumQuota;
          }
        }
        let stagePriorityPicked = 0;
        const lv2Index = LEVEL_ORDER.indexOf('Lv2');
        const normalizeRank = (stage)=>{
          if(stage === 'F') return -1;
          const idx = STAGE_PRIORITY.indexOf(stage);
          return idx === -1 ? STAGE_PRIORITY.length : idx;
        };

        for(const stage of STAGE_PRIORITY){
          if(stagePriorityPicked >= stagePriorityQuota) break;
          const arr = dueByStage.get(stage) || [];
          arr.sort((a,b)=>{
            const aDue = a.nextDue instanceof Date ? a.nextDue.getTime() : -Infinity;
            const bDue = b.nextDue instanceof Date ? b.nextDue.getTime() : -Infinity;
            if(aDue !== bDue) return aDue - bDue;
            return a.rand - b.rand;
          });
          for(const entry of arr){
            if(order.length >= n) break;
            if(stagePriorityPicked >= stagePriorityQuota) break;
            if(chosen.has(entry.idx)) continue;
            order.push({ idx:entry.idx, bucket:`Stage ${entry.stage}`, streak:entry.streak });
            chosen.add(entry.idx);
            stagePriorityPicked += 1;
          }
          if(order.length >= n) break;
        }

        const stageFTopUps = [];
        if(order.length < n){
          let stageFSlotsRemaining = Math.max(0, n - order.length);
          if(stageFSlotsRemaining > stageFPool.length && lv2Index !== -1){
            let stageFNeeded = stageFSlotsRemaining - stageFPool.length;
            const levelCandidates = (levelBuckets.get(lv2Index) || []).slice().sort((a,b)=>{
              const rankDiff = normalizeRank(a.stage) - normalizeRank(b.stage);
              if(rankDiff !== 0) return rankDiff;
              const aDue = a.nextDue instanceof Date ? a.nextDue.getTime() : Infinity;
              const bDue = b.nextDue instanceof Date ? b.nextDue.getTime() : Infinity;
              if(aDue !== bDue) return aDue - bDue;
              return a.rand - b.rand;
            });
            for(const entry of levelCandidates){
              if(stageFNeeded <= 0) break;
              if(chosen.has(entry.idx)) continue;
              const question = deckArr[entry.idx];
              const key = toKey(question);
              if(key) fallbackStageOverrides.set(key, 'F');
              stageByIndex.set(entry.idx, 'F');
              stageFTopUps.push({ idx:entry.idx, streak:entry.streak });
              stageFNeeded -= 1;
            }
          }
        }

        const shuffledF = shuffle(stageFPool.concat(stageFTopUps));
        for(const entry of shuffledF){
          if(order.length >= n) break;
          if(chosen.has(entry.idx)) continue;
          order.push({ idx:entry.idx, bucket:'Stage F', streak:entry.streak });
          chosen.add(entry.idx);
        }

        if(order.length < n){
          const levelRanks = Array.from(levelBuckets.keys())
            .filter(idx=>Number.isFinite(idx))
            .sort((a,b)=>b-a);
          for(const levelIdx of levelRanks){
            if(levelIdx === lv2Index) continue;
            const levelCandidates = (levelBuckets.get(levelIdx) || []).slice().sort((a,b)=>{
              const rankDiff = normalizeRank(a.stage) - normalizeRank(b.stage);
              if(rankDiff !== 0) return rankDiff;
              const aDue = a.nextDue instanceof Date ? a.nextDue.getTime() : Infinity;
              const bDue = b.nextDue instanceof Date ? b.nextDue.getTime() : Infinity;
              if(aDue !== bDue) return aDue - bDue;
              return a.rand - b.rand;
            });
            const levelLabel = LEVEL_ORDER[levelIdx] || '';
            for(const entry of levelCandidates){
              if(order.length >= n) break;
              if(chosen.has(entry.idx)) continue;
              const bucketLabel = levelLabel ? `Lv優先 (${levelLabel})` : 'Lv優先';
              order.push({ idx:entry.idx, bucket:bucketLabel, streak:entry.streak });
              chosen.add(entry.idx);
            }
            if(order.length >= n || chosen.size === deckArr.length) break;
          }
        }

        const stageFKeysToRemember = [];
        const seenStageFKeys = new Set();
        for(const entry of order){
          const stage = stageByIndex.get(entry.idx);
          if(stage !== 'F') continue;
          const question = deckArr[entry.idx];
          const key = toKey(question);
          if(!key || seenStageFKeys.has(key)) continue;
          seenStageFKeys.add(key);
          stageFKeysToRemember.push(key);
        }
        if(stageFKeysToRemember.length){
          rememberStageFKeys(stageFKeysToRemember);
        }

        lastOrder = order;

        if(order.length < targetCount){
          const shortage = targetCount - order.length;
          if(shortage > 0 && attempt < MAX_ATTEMPTS - 1){
            forcedExtraDeficit = Math.max(0, forcedExtraDeficit) + shortage;
            continue;
          }
        }

        return order;
      }

      return lastOrder;
    }






    function buildOrderFromWrong(strategy='all'){
      const wrong=getWrongQueue();
      if(wrong.length===0) return [];
      const need = Math.min(state.totalPerSet, wrong.length);
      let pool = [];
      if(strategy==='recent'){
        const cutoff = Date.now() - 7*24*3600*1000;
        const recent = wrong.filter(x=> x.at && (new Date(x.at).getTime()>=cutoff))
                            .sort((a,b)=> new Date(b.at)-new Date(a.at));
        pool = recent.slice(0, need);
        if(pool.length < need){
          const rest = wrong.filter(x=> !pool.includes(x));
          pool = pool.concat(rest.slice(0, need - pool.length));
        }
      }else{
        pool = wrong.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]).slice(0, need);
      }
      window.__REVIEW_DECK__ = pool.map(w=>({ ...w }));
      return [...window.__REVIEW_DECK__.keys()];
    }

    // === 成績インデックス（ローカル）: 過去データから弱点抽出 ===
    const PERF_KEY = (u)=>`quiz:${u}:perf`;
    function loadPerf(){ return JSON.parse(localStorage.getItem(PERF_KEY(state.user))||'{}'); }
    function savePerf(p){ localStorage.setItem(PERF_KEY(state.user), JSON.stringify(p)); }
    function noteAttempt(q, correct, at, mode){
      if(mode==='review') return; // 復習モードは記録しない
      const p = loadPerf();
      const k = questionKey(q);
      const rec = p[k] || { id:q.id||null, type:q.type, jp:q.jp, en:q.en, unit:q.unit||null, attempts:[] };
      rec.attempts.push({ correct: !!correct, at });
      const cutoff = Date.now() - 30*24*3600*1000; // 30日でローテ
      rec.attempts = rec.attempts.filter(a=> new Date(a.at).getTime() >= cutoff);
      p[k]=rec; savePerf(p);
    }
    function updateQuestionStat(q, bucket){
      const elStreak = $('#stat-streak');
      const elAcc = $('#stat-accuracy');
      const elBucket = $('#stat-bucket');
      const elStage = $('#stat-stage');
      elBucket.textContent = bucket ? `バケット: ${bucket}` : 'バケット: --';
      elStage.textContent = 'ステージ: --';
      if(!state.user || !q.id){
        elStreak.textContent='連続正解: --';
        elAcc.textContent='正解率: --';
        return;
      }
      fetch(`/api/stats?user=${encodeURIComponent(state.user)}&id=${encodeURIComponent(q.id)}&subject=${encodeURIComponent(SUBJECT)}`, {cache:'no-store'})
        .then(res=>res.ok?res.json():null)
        .then(data=>{
          if(!data){
            elStreak.textContent='連続正解: --';
            elAcc.textContent='正解率: --';
            elStage.textContent='ステージ: --';
            return;
          }
          const ans=data.answered||0; const ok=data.correct||0;
          elStreak.textContent = `連続正解: ${data.streak||0}`;
          elAcc.textContent = ans? `正解率: ${Math.round((ok/ans)*100)}% (${ok}/${ans})` : '正解率: --';
          elStage.textContent = data.stage ? `ステージ: ${data.stage}` : 'ステージ: --';
        })
        .catch(()=>{
          elStreak.textContent='連続正解: --';
          elAcc.textContent='正解率: --';
          elStage.textContent='ステージ: --';
        });
    }
    function weakCandidates(windowDays){
      const p = loadPerf();
      const cut = Date.now() - (windowDays*24*3600*1000);
      const list = [];
      const d = deck();
      for(const q of d){
        const k = questionKey(q);
        const rec = p[k];
        if(!rec || !rec.attempts || rec.attempts.length===0) continue;
        const arr = rec.attempts.filter(a=> new Date(a.at).getTime() >= cut);
        if(arr.length===0) continue;
        const wrong = arr.filter(a=>!a.correct).length;
        const acc = (arr.length - wrong)/arr.length;
        list.push({ q, acc, attempts: arr.length, wrong, lastAt: arr[arr.length-1].at });
      }
      // 低正答率 → 試行回数多 → 最近 の順
      list.sort((a,b)=> (a.acc - b.acc) || (b.attempts - a.attempts) || (new Date(b.lastAt)-new Date(a.lastAt)) );
      return list;
    }
    async function buildOrderWeak(windowDays=7){
      const stats = weakCandidates(windowDays);
      if(stats.length===0) return [];

      const entries = stats.map((item, idx)=>({
        idx,
        id: item && item.q && item.q.id != null ? String(item.q.id) : null,
      }));

      let filtered = stats.slice();
      const trimmedUser = (state.user || '').trim();
      const hasIds = entries.some(entry => entry.id);
      if(trimmedUser && hasIds){
        const stageStats = await fetchStatsForEntries(entries, trimmedUser);
        const nowMs = Date.now();
        filtered = stats.filter((item, idx)=>{
          const stat = stageStats[idx];
          if(!stat || typeof stat !== 'object') return true;
          const stage = normalizeStage(stat.stage);
          const nextDue = parseIsoDate(stat.nextDueAt);
          const nextDueMs = nextDue instanceof Date ? nextDue.getTime() : null;
          const isTrackedStage = STAGE_PRIORITY.includes(stage);
          return !(isTrackedStage && nextDueMs != null && nextDueMs > nowMs);
        });
      }

      if(filtered.length===0) return [];

      const pick = filtered.slice(0, Math.min(state.totalPerSet, filtered.length)).map(s=>s.q);
      window.__WEAK_DECK__ = pick;
      return pick.map((_,i)=>i);
    }

    async function startSet(){
      try{ await ensureQuestions(); }catch(e){ alert(e.message||e); return; }
      state.fallbackExtras = [];
      const fullDeck = deckByType(state.qType);
      if(!fullDeck.length){ alert(`この出題タイプの問題がありません。/data/${SUBJECT}/questions.json をご確認ください。`); show('setup'); return; }
      state.qIndex=0; state.correct=0; state.wrong=0; state.answered=[]; state.reviewed=[]; state.graded=false; state.choiceSelection=null;
      $('#stat-correct').textContent='0'; $('#stat-wrong').textContent='0';
      if(state.mode==='review'){
        const ord = buildOrderFromWrong(state.reviewStrategy||'all');
        if(ord.length===0){ alert('復習する問題がありません。まずは通常モードで間違いをためましょう。'); show('setup'); return; }
        state.order = ord.map(i=>({idx:i, bucket:null, streak:0}));
      }else if(state.mode==='weak'){
        const ord = await buildOrderWeak(state.weakWindowDays||7);
        if(ord.length===0){ alert('弱点候補が見つかりません（最近のデータが不足）。通常モードで解いてデータを増やしましょう。'); show('setup'); return; }
        state.order = ord.map(i=>({idx:i, bucket:null, streak:0}));
      }else{
        state.order = await buildOrderFromBank();
        if(!state.order.length){
          alert('選択した条件に合う問題がありません。条件を見直してください。');
          show('setup');
          return;
        }
      }
      show('quiz'); startTimer(); renderQuestion();
    }

    /********** 出題＆UI **********/
    function getCurrentQuestion(){
      const entry = state.order[state.qIndex];
      const idx = entry.idx;
      if(state.mode==='review') return window.__REVIEW_DECK__[idx];
      if(state.mode==='weak') return window.__WEAK_DECK__[idx];
      return deck()[idx];
    }

    function startTimer(){ state.startedAt=Date.now(); if(state.timerId) clearInterval(state.timerId); state.timerId=setInterval(()=>{ const sec=Math.floor((Date.now()-state.startedAt)/1000); $('#timer').textContent=`⏱ ${fmtTime(sec)}`; }, 250); }
    function stopTimer(){ if(state.timerId){ clearInterval(state.timerId); state.timerId=null; } }

    function updateChoiceButtons(){
      const options = $$('#vocab-choice-options .choice-option');
      const selectedValue = state.choiceSelection || '';
      options.forEach(btn=>{
        const value = btn.getAttribute('data-value') || '';
        const isSelected = value === selectedValue;
        const indexAttr = parseInt(btn.getAttribute('data-index') || '1', 10) - 1;
        btn.classList.toggle('selected', isSelected);
        btn.setAttribute('aria-checked', isSelected ? 'true' : 'false');
        btn.tabIndex = (isSelected || (!selectedValue && indexAttr === 0)) ? 0 : -1;
      });
    }

    function selectChoice(value){
      if(state.choiceSelection === value){
        state.choiceSelection = null;
      } else {
        state.choiceSelection = value;
      }
      updateChoiceButtons();
      updateNextState();
    }

    function renderQuestion(){
      const entry = state.order[state.qIndex];
      const q = getCurrentQuestion();
      updateQuestionStat(q, entry.bucket);
      state.graded = false;
      state.choiceSelection = null;
      $('#status').textContent = `Q ${state.qIndex+1}/${state.order.length}${state.mode==='review'?'（復習）':''}`;
      $('#explain').textContent='';

      if(state.qType==='reorder'){
        $('#ui-reorder').style.display='block';
        $('#ui-vocab').style.display='none';
        $('#ui-vocab-choice').style.display='none';
        $('#ui-rewrite').style.display='none';
        const basePrompt = q.jp || '<span class="muted">語順を並べ替えましょう</span>';
        $('#prompt').innerHTML = basePrompt;
        $('#btn-hint').disabled = !q.tip;
        const target=$('#target'); const bank=$('#bank'); target.innerHTML=''; bank.innerHTML='';
        let chunks = q.chunks.slice();
        if(entry.streak >= HARD_STREAK && q.wrong && q.wrong.length>0){
          const w = q.wrong[Math.floor(Math.random()*q.wrong.length)];
          chunks = chunks.concat(w);
        }
        chunks = shuffle(chunks);
        chunks.forEach((c,i)=>{
          const chip=document.createElement('button'); chip.className='chip'; chip.setAttribute('data-text',c); chip.textContent=`${i+1}. ${c}`;
          chip.onclick=()=>placeChip(chip); bank.appendChild(chip);
          chip.draggable=true; chip.ondragstart=e=>{ e.dataTransfer.setData('text/plain', c); chip.classList.add('dragging'); };
          chip.ondragend=()=>chip.classList.remove('dragging');
        });
        $('#target').ondragover=e=>{ e.preventDefault(); };
        $('#target').ondrop=e=>{ e.preventDefault(); const text=e.dataTransfer.getData('text/plain'); const src=[...$$('#bank .chip')].find(ch=>ch.getAttribute('data-text')===text && !ch.classList.contains('used')); if(src) placeChip(src); };
        $('#btn-next').disabled = true;
      } else if(state.qType==='vocab'){
        $('#ui-reorder').style.display='none';
        $('#ui-vocab').style.display='block';
        $('#ui-vocab-choice').style.display='none';
        $('#ui-rewrite').style.display='none';
        $('#prompt').innerHTML = `意味: <b>${q.jp}</b>`;
        $('#vocab-tip').innerHTML = '';
        $('#btn-hint').disabled = !q.tip;
        const inp = $('#vocab-input'); inp.value=''; inp.focus();
        $('#btn-next').disabled = false; // 入力だけなので次へボタンは常に押せる（採点は1回）
      } else if(state.qType==='vocab-choice'){
        $('#ui-reorder').style.display='none';
        $('#ui-vocab').style.display='none';
        $('#ui-vocab-choice').style.display='block';
        $('#ui-rewrite').style.display='none';
        const word = q.en || '<span class="muted">英単語を確認しましょう</span>';
        const pos = q.pos ? `<span class="muted">（${q.pos}）</span>` : '';
        $('#prompt').innerHTML = `英単語: <b>${word}</b> ${pos}`;
        $('#vocab-choice-tip').textContent = '';
        $('#btn-hint').disabled = !q.tip;
        const optionsEl = $('#vocab-choice-options');
        optionsEl.innerHTML='';
        const options = [];
        const seen = new Set();
        let hasCorrect = false;
        const correctText = typeof q.jp === 'string' ? q.jp.trim() : '';
        const pushOption = (text, isCorrect=false)=>{
          const trimmed = typeof text === 'string' ? text.trim() : '';
          if(!trimmed || seen.has(trimmed)) return;
          options.push({ text: trimmed, correct: !!isCorrect });
          seen.add(trimmed);
          if(isCorrect) hasCorrect = true;
        };
        const useCustomChoices = Array.isArray(q.choices) && q.choices.length>0;
        if(useCustomChoices){
          q.choices.forEach(choice=>{
            if(choice==null) return;
            if(typeof choice === 'string'){
              const isCorrect = !!(correctText && choice.trim() === correctText);
              pushOption(choice, isCorrect);
              return;
            }
            if(typeof choice === 'object'){
              const rawText = typeof choice.text === 'string'
                ? choice.text
                : (typeof choice.value === 'string' ? choice.value : '');
              const isCorrect = choice.correct === true || (!!correctText && rawText && rawText.trim() === correctText);
              pushOption(rawText, isCorrect);
            }
          });
        } else if(correctText){
          pushOption(correctText, true);
        }
        const pools = [
          deck().filter(item=> item && item.jp && item.id !== q.id),
          deckByType('vocab-choice').filter(item=> item && item.jp && item.id !== q.id),
        ];
        const fillFromPools = targetCount=>{
          for(const source of pools){
            const shuffled = shuffle(source);
            for(const candidate of shuffled){
              if(options.length >= targetCount) break;
              const text = typeof candidate.jp === 'string' ? candidate.jp.trim() : '';
              if(!text) continue;
              const isCorrect = !!(correctText && text === correctText);
              pushOption(text, isCorrect);
            }
            if(options.length >= targetCount) break;
          }
        };
        if(useCustomChoices){
          if(!hasCorrect && correctText){
            pushOption(correctText, true);
          }
          if(options.length < 2){
            fillFromPools(Math.max(options.length+1, 4));
          }
        } else {
          fillFromPools(4);
        }
        if(!hasCorrect && correctText){
          pushOption(correctText, true);
        }
        if(options.length < 2 && correctText){
          pushOption(correctText, true);
        }
        const finalOptions = shuffle(options);
        finalOptions.forEach((opt, idx)=>{
          const btn = document.createElement('button');
          btn.type='button';
          btn.className='choice-option';
          btn.setAttribute('data-value', opt.text);
          btn.setAttribute('data-index', String(idx+1));
          btn.setAttribute('role', 'radio');
          btn.setAttribute('aria-checked', 'false');
          btn.tabIndex = idx === 0 ? 0 : -1;
          btn.textContent = `${idx+1}. ${opt.text}`;
          btn.onclick=()=>selectChoice(opt.text);
          optionsEl.appendChild(btn);
        });
        updateChoiceButtons();
        const firstOption = $('#vocab-choice-options .choice-option');
        if(firstOption){ firstOption.focus(); }
        $('#btn-next').disabled = true;
      } else if(state.qType==='rewrite'){
        $('#ui-reorder').style.display='none';
        $('#ui-vocab').style.display='none';
        $('#ui-vocab-choice').style.display='none';
        $('#ui-rewrite').style.display='block';
        const instruction = q.jp || '<span class="muted">指示に従って英文を書き換えましょう</span>';
        $('#prompt').innerHTML = instruction;
        const extras = [];
        if(q.source) extras.push(`元の文: <b>${q.source}</b>`);
        if(q.task) extras.push(`指定: ${q.task}`);
        if(q.note) extras.push(q.note);
        $('#rewrite-extra').innerHTML = extras.join('<br>');
        $('#rewrite-tip').innerHTML = '';
        $('#btn-hint').disabled = !q.tip;
        const area = $('#rewrite-input'); area.value=''; area.focus();
        $('#btn-next').disabled = false;
      }
      updateNextState();
    }

    function showHint(){
      const q = getCurrentQuestion();
      if(!q.tip) return;
      if(state.qType==='reorder'){
        const base = q.jp || '<span class="muted">語順を並べ替えましょう</span>';
        $('#prompt').innerHTML = `${base}<br><span class="muted">ヒント: ${q.tip}</span>`;
      } else if(state.qType==='vocab'){
        $('#vocab-tip').innerHTML = `ヒント: ${q.tip}`;
      } else if(state.qType==='vocab-choice'){
        $('#vocab-choice-tip').textContent = `ヒント: ${q.tip}`;
      } else if(state.qType==='rewrite'){
        $('#rewrite-tip').innerHTML = `ヒント: ${q.tip}`;
      }
    }

    function placeChip(chip){ if(chip.classList.contains('used')) return; chip.classList.add('used'); const btn=document.createElement('button'); btn.className='chip'; btn.textContent=chip.getAttribute('data-text'); btn.onclick=()=>{ btn.remove(); chip.classList.remove('used'); updateNextState(); }; $('#target').appendChild(btn); updateNextState(); }
    function undo(){ if(state.qType!=='reorder') return; const t=$$('#target .chip'); const last=t[t.length-1]; if(!last) return; const text=last.textContent; last.remove(); const bankChip=[...$$('#bank .chip')].find(c=>c.getAttribute('data-text')===text); if(bankChip) bankChip.classList.remove('used'); updateNextState(); }
    function clearAnswer(){
      if(state.qType==='reorder'){
        $$('#target .chip').forEach(n=>n.remove());
        $$('#bank .chip').forEach(n=>n.classList.remove('used'));
        updateNextState();
      } else if(state.qType==='vocab-choice'){
        state.choiceSelection = null;
        updateChoiceButtons();
        const firstOption = $('#vocab-choice-options .choice-option');
        if(firstOption){ firstOption.focus(); }
        updateNextState();
      } else {
        const inp = typedInputElement();
        if(inp){ inp.value=''; inp.focus(); }
        updateNextState();
      }
    }

    function currentAnswer(){
      if(state.qType==='reorder'){
        return [...$('#target').children].map(x=>x.textContent).join(' ');
      }
      if(state.qType==='vocab-choice'){
        return state.choiceSelection || '';
      }
      const inp = typedInputElement();
      return inp? (inp.value||'') : '';
    }
    function updateNextState(){
      const btnCheck = $('#btn-check');
      const btnNext = $('#btn-next');
      if(!btnCheck || !btnNext) return;
      if(state.qType==='reorder'){
        const hasAnswer = $$('#target .chip').length > 0;
        btnCheck.disabled = state.graded || !hasAnswer;
        btnNext.disabled = state.graded ? false : true;
      } else if(state.qType==='vocab-choice'){
        const hasSelection = !!(state.choiceSelection && state.choiceSelection.trim());
        btnCheck.disabled = state.graded || !hasSelection;
        btnNext.disabled = state.graded ? false : true;
      } else {
        const inp = typedInputElement();
        const value = inp ? (inp.value || '').trim() : '';
        btnCheck.disabled = state.graded || value.length===0;
        btnNext.disabled = false;
      }
    }

    function buildFeedbackDetail(q, includeTip=false){
      const lines = [];
      if(q.explain) lines.push(q.explain);
      if(includeTip && q.tip) lines.push(q.tip);
      if(lines.length===0) return '';
      return '<br>' + lines.map(text=>`<span class="muted">${text}</span>`).join('<br>');
    }

    function formatCorrectAnswers(list){
      const answers = (Array.isArray(list)? list : [list]).filter(Boolean);
      if(!answers.length) return '<span class="muted">（正解未設定）</span>';
      if(answers.length===1) return `<b>${answers[0]}</b>`;
      return answers.map(ans=>`<b>${ans}</b>`).join('<br><span class="muted">または</span> ');
    }

    /********** 採点・進行 **********/
    function checkAnswer(){
      if(state.graded) return; // 二重加算防止
      const q = getCurrentQuestion();

      const answerList = state.qType==='vocab-choice'
        ? ((q.jp ? [q.jp] : []).filter(Boolean))
        : ((Array.isArray(q.answers) && q.answers.length) ? q.answers : [q.en]);
      let ans, correct;
      if(state.qType==='reorder'){
        const keepPunc = true; // 並び替えでは文末記号を保持する
        const normalizedAns = normalizeEndPunc(normalizeSpaces(currentAnswer()), keepPunc);
        ans = normalizedAns? normalizedAns.charAt(0).toUpperCase()+normalizedAns.slice(1) : normalizedAns;
        const normalizedAnswers = answerList.map(a=>normalizeEndPunc(normalizeSpaces(a), keepPunc));
        const normalizedAnsLower = typeof normalizedAns === 'string' ? normalizedAns.toLowerCase() : normalizedAns;
        const normalizedAnswersLower = normalizedAnswers.map(a=>typeof a === 'string' ? a.toLowerCase() : a);
        correct = normalizedAnswersLower.includes(normalizedAnsLower);
      } else if(state.qType==='vocab-choice'){
        ans = normalizeSpaces(currentAnswer());
        const normalizedCorrect = answerList.map(a=>normalizeSpaces(a));
        correct = normalizedCorrect.includes(ans);
      } else if(state.qType==='rewrite'){
        const keepPunc = true;
        const normalizedAns = normalizeEndPunc(normalizeSpaces(currentAnswer()), keepPunc);
        ans = normalizedAns? normalizedAns.charAt(0).toUpperCase()+normalizedAns.slice(1) : normalizedAns;
        const normalizedAnswers = answerList.map(a=>normalizeEndPunc(normalizeSpaces(a), keepPunc));
        const normalizedAnsLower = typeof normalizedAns === 'string' ? normalizedAns.toLowerCase() : normalizedAns;
        const normalizedAnswersLower = normalizedAnswers.map(a=>typeof a === 'string' ? a.toLowerCase() : a);
        correct = normalizedAnswersLower.includes(normalizedAnsLower);
      } else { // vocab
        ans = normalizeWord(currentAnswer());
        const normalizedAnswers = answerList.map(a=>normalizeWord(a));
        correct = normalizedAnswers.includes(ans);
      }

      const record = {
        type: state.qType,
        id: q.id||null,
        unit: q.unit||null,
        userAnswer: ans,
        correct,
        setIndex: state.setIndex, qIndex: state.qIndex, mode: (state.mode||'normal'),
        at: nowISO()
      };

      if(correct){
        state.correct++; $('#stat-correct').textContent = state.correct;
        const detail = buildFeedbackDetail(q, false);
        $('#explain').innerHTML = `✅ 正解！ <span class="muted">${ans}</span>${detail}`;
        removeFromWrongIfMatched({id:q.id, jp:q.jp, en:q.en});
      } else {
        state.wrong++; $('#stat-wrong').textContent = state.wrong;
        const detail = buildFeedbackDetail(q, true);
        const answersMarkup = formatCorrectAnswers(answerList);
        $('#explain').innerHTML = state.qType==='reorder'
          ? `❌ 不正解。 正解: ${answersMarkup}${detail}`
          : `❌ 不正解。 正解: ${answersMarkup}${detail}`;
        // 復習用には詳細保持
        addWrongLocal({ type:state.qType, id:q.id||null, unit:q.unit||null, level:q.level||DEFAULT_LEVEL, jp:q.jp, en:q.en, chunks:q.chunks, tip:q.tip||'', explain:q.explain||'', source:q.source||'', task:q.task||'', userAnswer: ans, at: record.at });
      }

      (state.mode==='review'? state.reviewed : state.answered).push(record);
      noteAttempt(q, correct, record.at, state.mode);
      updateQuestionStat(q, state.order[state.qIndex].bucket);
      state.graded = true;
      $('#btn-next').disabled = false;
      updateNextState();
    }

    function nextQuestion(){
      if(!state.graded) checkAnswer();
      state.qIndex++;
      if(state.qIndex >= state.order.length){ finishSet(); }
      else { renderQuestion(); }
    }

    function finishSet(){
      stopTimer();
      const total = state.order.length;
      const accuracy = total? Math.round((state.correct/total)*100):0;
      const seconds = Math.floor((Date.now()-state.startedAt)/1000);
      $('#summary').innerHTML = `正解 <b>${state.correct}</b> / ${total}（<b>${accuracy}%</b>）・所要時間 ${Math.floor(seconds/60)}分${seconds%60}秒`;
      show('finished');

      // --- このセットの誤答だけを抽出してボタンに渡す ---
      const srcDeck = (state.mode==='review') ? window.__REVIEW_DECK__
                    : (state.mode==='weak')  ? window.__WEAK_DECK__
                    : deck();

      // 解答記録（通常 or 復習）の qIndex は「state.order 上の位置」
      const records = (state.mode==='review') ? state.reviewed : state.answered;
      const missedObjs = records
        .filter(r=>!r.correct)
        .map(r=>{
          const idxInSrc = state.order[r.qIndex].idx;
          return srcDeck[idxInSrc];
        })
        .filter(Boolean);

      // 状態に保持して、ボタン表示を更新
      state.missedSetDeck = missedObjs;
      const btnReviewThis = document.getElementById('btn-review-thisset');
      if(btnReviewThis){
        const n = missedObjs.length;
        btnReviewThis.disabled = (n===0);
        btnReviewThis.textContent = n
          ? `❗このセットのまちがいで復習（${n}問）`
          : `❗このセットのまちがいで復習（0問）`;
      }

      const wireAnswered = state.answered.map(({type,id,unit,userAnswer,correct,setIndex,qIndex,mode,at})=>({type,id,unit,userAnswer,correct,setIndex,qIndex,mode,at}));
      const wireReviewed = state.reviewed.map(({type,id,unit,userAnswer,correct,setIndex,qIndex,mode,at})=>({type,id,unit,userAnswer,correct,setIndex,qIndex,mode,at}));
      const wireCorrect  = wireAnswered.filter(x=>x.correct);
      const wireMissed   = wireAnswered.filter(x=>!x.correct);
      const wireReviewMissed = wireReviewed.filter(x=>!x.correct);

      const sessionWire = {
        user: state.user,
        setIndex: state.setIndex,
        mode: state.mode||'normal',
        qType: state.qType,
        total,
        correct: state.correct,
        wrong: total - state.correct,
        accuracy,
        seconds,
        endedAt: nowISO(),
        answered: wireAnswered,
        correctItems: wireCorrect,
        missed: wireMissed,
        reviewed: wireReviewed,
        reviewMissed: wireReviewMissed
      };

      // ローカル履歴はサマリのみ（軽量）
      pushHistory({ user: state.user, setIndex: state.setIndex, mode: state.mode||'normal', qType: state.qType, total, correct: state.correct, wrong: total-state.correct, accuracy, seconds, endedAt: sessionWire.endedAt });

      const saveEl = document.getElementById('save-status');
      const url = state.endpoint || DEFAULT_ENDPOINT;
      if(url){
        saveEl.textContent = '結果送信: 送信中…';
        const payload = { ...sessionWire, subject: SUBJECT };
        console.log('[POST] results =>', url, payload);
        postJSON(url, payload).then(r=>{
          if(r.ok){ saveEl.innerHTML = '<span class="ok">結果送信: 成功</span>'; }
          else { saveEl.innerHTML = `<span class=\"ng\">結果送信: 失敗</span> ${r.status||r.error||''}`; }
        });
      } else {
        saveEl.textContent = '結果送信: URL未設定（ローカル保存のみ）';
      }
    }

    /********** イベント **********/
    document.getElementById('btn-start').onclick=async ()=>{
      try{
        state.user=(document.getElementById('learner').value||'guest').trim()||'guest';
        document.getElementById('user-pill').textContent=`👤 ${state.user}`;
        clearStageFHistoryCache();
        state.totalPerSet=Math.max(3,Math.min(20,parseInt(document.getElementById('count').value||7,10)));
        state.endpoint=DEFAULT_ENDPOINT;
        state.setIndex=0; state.mode='normal'; state.qType=document.getElementById('qtype').value||'reorder';
        const unitSel=document.getElementById('unit-filter');
        if(unitSel){
          const selected=(unitSel.value||'').trim();
          if(BANK_REORDER.length || BANK_VOCAB_INPUT.length || BANK_VOCAB_CHOICE.length || !state.unitFilter){
            state.unitFilter=selected;
          }
        }
        rememberSettings();
        await startSet();
      }catch(e){ alert('開始できません: '+(e.message||e)); }
    };

    document.getElementById('btn-review-thisset').onclick = async ()=>{
      const deck = (state.missedSetDeck||[]).map(q=>({ ...q }));
      await startSetCustom(deck);
    };

    // 弱点対策（過去7日）
    document.getElementById('btn-weak').onclick=async ()=>{
      try{
        state.user=(document.getElementById('learner').value||'guest').trim()||'guest';
        document.getElementById('user-pill').textContent=`👤 ${state.user}`;
        clearStageFHistoryCache();
        state.totalPerSet=Math.max(3,Math.min(20,parseInt(document.getElementById('count').value||7,10)));
        state.endpoint=DEFAULT_ENDPOINT;
        state.setIndex=0; state.mode='weak'; state.qType=document.getElementById('qtype').value||'reorder';
        const unitSel=document.getElementById('unit-filter');
        if(unitSel){
          const selected=(unitSel.value||'').trim();
          if(BANK_REORDER.length || BANK_VOCAB_INPUT.length || BANK_VOCAB_CHOICE.length || !state.unitFilter){
            state.unitFilter=selected;
          }
        }
        rememberSettings();
        await startSet();
      }catch(e){ alert('弱点対策を開始できません: '+(e.message||e)); }
    };
   
    // 入力欄変更で即保存＋サジェスト更新
    document.getElementById('learner').addEventListener('change', (e)=>{
      const v=(e.target.value||'').trim(); if(!v) return;
      state.user=v; document.getElementById('user-pill').textContent=`👤 ${v}`;
      clearStageFHistoryCache();
      rememberSettings();
    });
    document.getElementById('unit-filter').addEventListener('change', (e)=>{
      const v=(e.target.value||'').trim();
      state.unitFilter=v;
      rememberSettings();
    });
    document.getElementById('qtype').addEventListener('change', async (e)=>{
      const v=(e.target.value||'').trim(); if(!v) return;
      state.qType=v;
      state.unitFilter = getRememberedUnitFilter(state.qType);
      try{
        await ensureQuestions();
      }catch(err){
        console.error('ensureQuestions failed', err);
        alert('問題の読み込みに失敗: '+(err.message||err));
      }
      renderUnitFilterOptions();
      const sel=document.getElementById('unit-filter');
      if(sel){ state.unitFilter=(sel.value||'').trim(); }
      rememberSettings();
    });

    document.getElementById('btn-check').onclick=checkAnswer; document.getElementById('btn-next').onclick=nextQuestion; document.getElementById('btn-undo').onclick=undo; document.getElementById('btn-clear').onclick=clearAnswer; document.getElementById('btn-clear-vocab').onclick=()=>{ $('#vocab-input').value=''; $('#vocab-input').focus(); updateNextState(); }; document.getElementById('btn-clear-rewrite').onclick=()=>{ $('#rewrite-input').value=''; $('#rewrite-input').focus(); updateNextState(); }; document.getElementById('btn-hint').onclick=showHint;
    document.getElementById('vocab-input').addEventListener('input', updateNextState);
    document.getElementById('rewrite-input').addEventListener('input', updateNextState);
    document.getElementById('btn-speak').onclick=()=>{
      const q=getCurrentQuestion();
      if(!q) return;
      const text = (Array.isArray(q.answers) && q.answers.length) ? q.answers[0] : q.en;
      const u=new SpeechSynthesisUtterance(text);
      u.lang='en-US';
      u.rate=1.0;
      speechSynthesis.cancel();
      speechSynthesis.speak(u);
    };

    // 完了画面の遷移
      document.getElementById('btn-nextset').onclick=async ()=>{
        try{
          state.setIndex++;
          if(state.mode==='review'){ state.mode='normal'; }
          await startSet();
        }catch(e){
          alert('次セットを開始できません: '+(e.message||e));
        }
      };
    document.getElementById('btn-dashboard').onclick=()=>{ 
      try{ 
        const u = encodeURIComponent(state.user||'');
        window.location.href = `/admin?user=${u}`;
      }catch(e){ 
        alert('ダッシュボードへ移動できません: '+(e.message||e)); 
      } 
    };
    document.getElementById('btn-to-setup').onclick=()=>{ show('setup'); };

    // キーボード（Enterで採点/次へ＋iOSでキーボードを閉じる）
    window.addEventListener('keydown',(e)=>{
      if(document.getElementById('quiz').style.display==='none') return;
      if(state.qType==='reorder'){
        if(e.key>='1' && e.key<='9'){ const idx=parseInt(e.key,10)-1; const chips=$$('#bank .chip'); const chip=chips[idx]; if(chip) placeChip(chip); }
        else if(e.key==='Backspace'){ e.preventDefault(); undo(); }
      } else if(state.qType==='vocab-choice'){
        if(e.key>='1' && e.key<='9'){
          const idx=parseInt(e.key,10)-1;
          const options=$$('#vocab-choice-options .choice-option');
          const target=options[idx];
          if(target){ target.click(); }
        }
      }
      if(e.key==='Enter'){
        e.preventDefault();
        if(!state.graded){ checkAnswer(); }
        else { nextQuestion(); }
        if(document.activeElement && document.activeElement.blur){ document.activeElement.blur(); }
      }
    });

    // 初期
    loadRememberedSettings();
    ensureQuestions().catch(err=>{ console.error('ensureQuestions failed at init', err); });
    show('setup');
  </script>
</body>
</html>
