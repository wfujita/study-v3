<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>英語クイズ｜並べ替え＋単語（意味→スペル）</title>
  <style>
    :root{ --bg:#0f172a; --card:#111827; --muted:#94a3b8; --text:#e5e7eb; --border:#1f2937; --accent:#3b82f6; --warn:#ef4444 }
    *{ box-sizing:border-box }
    body{ margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif; -webkit-text-size-adjust:100% }
    header{ position:sticky; top:0; background:rgba(17,24,39,.9); backdrop-filter:saturate(150%) blur(6px); border-bottom:1px solid var(--border); z-index:10 }
    .container{ max-width:980px; margin:0 auto; padding:16px }
    .card{ background:var(--card); border:1px solid var(--border); border-radius:14px; padding:16px; margin:16px 0 }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
    .pill{ display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius:999px; border:1px solid #334155; background:#0b1220; color:#cbd5e1; font-size:12px }
    input,select{ background:#0b1220; color:#e5e7eb; border:1px solid #334155; border-radius:12px; padding:8px 10px }
    button{ border:1px solid #334155; background:#1f2937; color:#e5e7eb; border-radius:12px; padding:10px 14px; font-weight:700; cursor:pointer }
    button.primary{ background:var(--accent); border-color:var(--accent); color:white }
    button.warn{ background:var(--warn); border-color:var(--warn); color:white }
    button:disabled{ opacity:.5; cursor:not-allowed }
    .muted{ color:var(--muted) }
    .right{ margin-left:auto }
    .kbd{ font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; border:1px solid #334155; background:#0b1220; border-radius:6px; padding:2px 6px; color:#cbd5e1 }
    .target{ min-height:52px; padding:8px; background:#0b1220; border:2px dashed var(--accent); border-radius:12px; display:flex; gap:8px; flex-wrap:wrap }
    .bank{ display:flex; flex-wrap:wrap; gap:8px }
    .chip{ background:#0b1220; border:1px solid #334155; border-radius:999px; padding:8px 12px; cursor:pointer; transition:.15s; user-select:none; min-height:44px }
    .chip:hover{ transform:translateY(-1px) }
    .chip.used{ opacity:.45; cursor:default }
    .ok{ color:#22c55e } .ng{ color:#ef4444 }
    .field{ display:flex; gap:8px; align-items:center }
    .input{ background:#0b1220; color:#e5e7eb; border:1px solid #334155; border-radius:10px; padding:10px 12px; min-width:240px }

    /* iOS Safari フォーカス時の自動ズーム抑止：16px以上に統一 */
    @supports (-webkit-touch-callout: none) {
      input, select, textarea { font-size:16px; line-height:1.2; }
      .input { font-size:16px; }
      #count { font-size:16px; }
    }
    input, select, textarea { min-height:44px; }

    /* --- モバイル最適化 & 操作ボタンの押しやすさ改善 --- */
    :root{ --tap:44px }
    body{ touch-action:manipulation }
    #vocab-input{ width:100% }
    #target,#bank{ gap:10px }
    #bank{ max-height:40vh; overflow:auto; padding-bottom:6px }

    /* 操作ボタン配置：解答確認を最優先・大きく */
    #quiz .actions{ display:flex; flex-wrap:wrap; gap:10px; }
    #btn-check{ order:1; flex:1 1 100%; padding:14px 18px; font-size:18px; }
    #btn-next{ order:2; flex:1 1 48%; }
    #btn-undo, #btn-clear, #btn-speak{ order:3; flex:1 1 30%; min-width:120px }
    @media (min-width:820px){
      #btn-check{ flex-basis:60%; font-size:16px; }
      #btn-next{ flex-basis:auto; }
    }
  </style>
</head>
<body>
  <header>
    <div class="container row">
      <div>
        <h2 style="margin:0">英語クイズ <span class="muted">（並べ替え＋単語）</span></h2>
        <div class="muted" style="font-size:12px">外部JSON／復習モード／一問一採点／完了時は最小ペイロードをサーバ保存。</div>
      </div>
      <div class="right pill" id="user-pill">👤 ゲスト</div>
    </div>
  </header>

  <main class="container">
    <!-- 設定 -->
    <section class="card" id="setup">
      <div class="row">
        <label class="row" style="gap:6px"><span class="muted">学習者名</span><input id="learner" type="text" placeholder="taro" autocomplete="off" autocapitalize="off" list="user-suggestions" /></label><datalist id="user-suggestions"></datalist>
        <label class="row" style="gap:6px"><span class="muted">1セットの出題数</span><input id="count" type="number" min="3" max="20" value="5" style="width:80px"/></label>
        <label class="row" style="gap:6px"><span class="muted">出題タイプ</span>
          <select id="qtype">
            <option value="reorder">並べ替え（文法）</option>
            <option value="vocab" selected>単語（意味→スペル）</option>
          </select>
        </label>
        <label class="row" style="gap:6px"><span class="muted">レベル</span>
          <select id="level-filter">
            <option value="Lv1" selected>Lv1（中学一年生相当）</option>
            <option value="Lv2">Lv2（中学二年生相当）</option>
            <option value="Lv3">Lv3（中学三年生相当）</option>
          </select>
        </label>
        <label class="row" style="gap:6px"><span class="muted">ユニット</span>
          <select id="unit-filter">
            <option value="">全ユニット</option>
          </select>
        </label>
        <button class="primary" id="btn-start">▶ 学習スタート</button>
        <button id="btn-weak" title="過去7日の正答率が低い問題">🎯 弱点対策（過去7日）</button>
      </div>
      <div class="muted" style="margin-top:8px">
        並べ替え: <span class="kbd">1-9</span> で選択、<span class="kbd">Backspace</span> で戻す、<span class="kbd">Enter</span> で採点/次へ。<br>
        単語: 入力欄にスペルを入力（英字・大文字小文字は不問）。
        <br>レベルの目安: Lv1＝中学一年生、Lv2＝中学二年生、Lv3＝中学三年生。
      </div>
    </section>

    <!-- クイズ（共通ヘッダ） -->
    <section class="card" id="quiz" style="display:none">
      <div class="row">
          <span class="pill" id="status">Q 1/5</span>
          <span class="pill">正解: <b id="stat-correct">0</b></span>
          <span class="pill">誤答: <b id="stat-wrong">0</b></span>
          <span class="pill" id="stat-streak">連続正解: --</span>
          <span class="pill" id="stat-accuracy">正解率: --</span>
          <span class="pill" id="stat-stage">ランク: --</span>
          <span class="pill" id="stat-bucket">バケット: --</span>
          <span class="pill right" id="timer">⏱ 00:00</span>
      </div>
      <div id="prompt" class="muted">（日本語プロンプト）</div>

      <!-- 並べ替えUI -->
      <div id="ui-reorder">
        <div id="target" class="target" aria-label="答えのエリア"></div>
        <div id="bank" class="bank" aria-label="単語のエリア"></div>
      </div>

      <!-- 単語UI -->
      <div id="ui-vocab" style="display:none; margin-top:10px">
        <div class="field">
          <input id="vocab-input" class="input" type="text" placeholder="スペルを入力（例: interesting）" autocomplete="off" autocapitalize="off" autocorrect="off" inputmode="latin" />
          <button id="btn-clear-vocab">🧹 クリア</button>
        </div>
        <div class="muted" id="vocab-tip" style="margin-top:6px"></div>
      </div>

      <div class="row actions" style="margin-top:10px">
        <button class="primary" id="btn-check">答え合わせ <span class="kbd">Enter</span></button>
        <button id="btn-next" disabled>次の問題 ▶</button>
        <button id="btn-undo">↩ ひとつ戻す</button>
        <button id="btn-clear">🧹 クリア</button>
        <button id="btn-speak">🔊 正解文/単語</button>
        <button id="btn-hint">💡 ヒント</button>
      </div>
      <div id="explain" class="muted" style="min-height:1.6em"></div>
    </section>

    <!-- セット終了 -->
    <section class="card" id="finished" style="display:none">
      <h3 style="margin:0 0 8px">セット完了！</h3>
      <p id="summary" class="muted"></p>
      <p id="save-status" class="muted">結果送信: 待機中…</p>
      <div class="row">
        <button class="primary" id="btn-review-thisset" disabled>❗このセットのまちがいで復習</button>
        <button class="primary" id="btn-nextset">▶ 次の問題群（次セット）</button>
        <button id="btn-dashboard">📊 成績を見る</button>
        <button class="warn right" id="btn-to-setup">設定に戻る</button>
      </div>
    </section>
  </main>

  <script>
    /********** 設定 **********/
    const SUBJECT = 'english';
    const QUESTIONS_URL = `/data/${SUBJECT}/questions.json`; // Flaskで配信
    const DEFAULT_ENDPOINT = "/api/results";
    const LEVEL_ORDER = ['Lv1','Lv2','Lv3'];
    const DEFAULT_LEVEL = LEVEL_ORDER[0];

    // 設定の記憶用キー
    const REMEMBER_USER_KEY = 'quiz:lastUser';
    const REMEMBER_QTYPE_KEY = 'quiz:lastQType';
    const REMEMBER_UNIT_KEY = 'quiz:lastUnitFilter';
    const REMEMBER_LEVEL_KEY = 'quiz:lastLevel';
    const USER_SUGGEST_KEY = 'quiz:userList';

    /********** 問題ロード **********/
    let BANK_REORDER = [];
    let BANK_VOCAB = [];

    const toAnswerList = (value)=>{
      if(Array.isArray(value)){
        return value
          .map(v=>typeof v==='string'? v.trim(): '')
          .filter(v=>v);
      }
      if(typeof value==='string'){
        const trimmed = value.trim();
        return trimmed? [trimmed] : [];
      }
      return [];
    };

    const collectAnswerSet = (item)=>{
      const primary = toAnswerList(item.en);
      const extras = [];
      [item.accept, item.accepts, item.answers, item.alternates, item.variants]
        .forEach(src=>{ toAnswerList(src).forEach(ans=>extras.push(ans)); });
      const merged = [...primary, ...extras];
      if(!merged.length && typeof item.en==='string'){
        const fallback = item.en.trim();
        if(fallback) merged.push(fallback);
      }
      const unique = [];
      merged.forEach(ans=>{ if(!unique.includes(ans)) unique.push(ans); });
      return unique;
    };

    const normalizeLevel = (value)=>{
      const str = (value==null ? '' : String(value)).trim();
      if(LEVEL_ORDER.includes(str)) return str;
      const match = str.match(/([1-3])/);
      if(match){
        const candidate = `Lv${match[1]}`;
        if(LEVEL_ORDER.includes(candidate)) return candidate;
      }
      return DEFAULT_LEVEL;
    };

    const levelIndex = (value)=>{
      const lvl = normalizeLevel(value);
      const idx = LEVEL_ORDER.indexOf(lvl);
      return idx === -1 ? LEVEL_ORDER.length : idx;
    };

    const buildQuestion = (item, type)=>{
      const answers = collectAnswerSet(item);
      const primary = answers[0] || (typeof item.en==='string'? item.en.trim(): '');
      const base = {
        type,
        id: item.id||null,
        unit: item.unit||null,
        jp: item.jp,
        en: primary,
        answers,
        tip: item.tip||'',
        explain: item.explain||'',
        level: normalizeLevel(item.level)
      };
      if(type==='reorder'){
        base.chunks = item.chunks;
        base.wrong = item.wrong||[];
      } else if(type==='vocab'){
        base.pos = item.pos||'';
      }
      return base;
    };
    async function ensureQuestions(){
      if (BANK_REORDER.length || BANK_VOCAB.length){ renderUnitFilterOptions(); return; }
      const res = await fetch(QUESTIONS_URL, { cache: "no-store" });
      if (!res.ok) throw new Error("質問ファイルの読み込みに失敗: " + res.status);
      const data = await res.json();
      // 互換: 旧形式 questions は並べ替え扱い
      BANK_REORDER = (data.questions||data.reorder||[]).map(q=>buildQuestion(q, 'reorder'));
      BANK_VOCAB   = (data.vocab||[]).map(v=>buildQuestion(v, 'vocab'));
      renderUnitFilterOptions();
    }

    /********** 状態 **********/
    const state = {
      user:'guest', endpoint: DEFAULT_ENDPOINT,
      qType:'reorder',
      unitFilter:'',
      levelMax: DEFAULT_LEVEL,
      totalPerSet:5, order:[], setIndex:0,
      qIndex:0, correct:0, wrong:0,
      startedAt:null, seconds:0, timerId:null,
      answered:[],   // サーバ送信用（通常モード）
      reviewed:[],   // サーバ送信用（復習モード）
      graded:false,  // 一問一採点
      mode:'normal',
      reviewStrategy:'all', // 'all' | 'recent'
      weakWindowDays:7,      // 過去◯日を対象
      missedSetDeck: [],   // このセットで間違えた問題のデッキ
    };

    const $ = s=>document.querySelector(s);
    const $$ = s=>Array.from(document.querySelectorAll(s));

    /********** ユーティリティ **********/
    const fmtTime = s=>{ const m=String(Math.floor(s/60)).padStart(2,'0'); const r=String(s%60).padStart(2,'0'); return `${m}:${r}` };
    const shuffle = arr=>arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);
    const NBSP = String.fromCharCode(160);
    const normalizeDigits = s=> (s==null ? '' : String(s).replace(/[０-９]/g, ch=> String.fromCharCode(ch.charCodeAt(0)-0xFEE0)));
    const normalizeSpaces = s=> normalizeDigits(s).replace(new RegExp(`[${NBSP}\\s]+`,'g'),' ').trim();
    const normalizeEndPunc = (s, keep=false)=> keep ? s.replace(/\s+([.,!?])/g, "$1") : s.replace(/\s*[.,!?]$/,'');
    const normalizeWord = s=> normalizeSpaces(s).toLowerCase();
    const normalizeUnit = u=> (u===null || u===undefined ? '' : String(u).trim());
    const HARD_STREAK = 2;
    const nowISO = ()=> new Date().toISOString();

    async function postJSON(url, data, timeoutMs=6000){
      const ctrl = new AbortController();
      const t = setTimeout(()=>ctrl.abort(), timeoutMs);
      try{
        const res = await fetch(url,{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(data), signal: ctrl.signal});
        clearTimeout(t);
        return {ok: res.ok, status: res.status};
      }catch(e){ clearTimeout(t); return {ok:false, error:String(e)}; }
    }

    async function startSetCustom(customDeck){
      try{ await ensureQuestions(); }catch(e){ alert(e.message||e); return; }
      if(!customDeck || !customDeck.length){ alert('このセットの間違いはありません。'); return; }

      // セット初期化
      state.qIndex=0; state.correct=0; state.wrong=0; state.answered=[]; state.reviewed=[]; state.graded=false;
      $('#stat-correct').textContent='0'; $('#stat-wrong').textContent='0';

      // レビュー用デッキに流し込む（既存ロジック流用）
      window.__REVIEW_DECK__ = customDeck.map(q=>({ ...q }));
      state.order = [...window.__REVIEW_DECK__.keys()].map(i=>({idx:i, bucket:null, streak:0}));
      state.mode = 'review';
      // 表示UIを合わせる（並べ替え/単語）
      state.qType = (window.__REVIEW_DECK__[0]?.type) || state.qType;

      show('quiz'); startTimer(); renderQuestion();
    }

    /********** 設定の記憶（ユーザー名・出題タイプ） **********/
    function populateUserSuggestions(){
      const dl=document.getElementById('user-suggestions'); if(!dl) return;
      const list=JSON.parse(localStorage.getItem(USER_SUGGEST_KEY)||'[]');
      dl.innerHTML='';
      list.forEach(name=>{ const opt=document.createElement('option'); opt.value=name; dl.appendChild(opt); });
    }

    function readRememberedUnitMap(){
      try{
        const raw = localStorage.getItem(REMEMBER_UNIT_KEY);
        if(!raw) return {};
        const data = JSON.parse(raw);
        return (data && typeof data === 'object') ? data : {};
      }catch(e){
        return {};
      }
    }
    function writeRememberedUnitMap(map){
      try{
        localStorage.setItem(REMEMBER_UNIT_KEY, JSON.stringify(map));
      }catch(e){
        // ignore
      }
    }
    function getRememberedUnitFilter(qType){
      const map = readRememberedUnitMap();
      const val = map && typeof map === 'object' ? map[qType] : '';
      return (typeof val === 'string') ? val : '';
    }
    function rememberUnitFilter(qType, value){
      const map = readRememberedUnitMap();
      const v = (value || '').trim();
      if(v){ map[qType] = v; }
      else { delete map[qType]; }
      writeRememberedUnitMap(map);
    }

    function renderUnitFilterOptions(){
      const sel = document.getElementById('unit-filter');
      if(!sel) return;
      const deckArr = deckByType(state.qType).filter(q=> levelIndex(q.level) <= levelIndex(state.levelMax));
      const units = Array.from(new Set(deckArr.map(q=>normalizeUnit(q.unit)).filter(u=>u))).sort((a,b)=>a.localeCompare(b, 'ja', { numeric:true, sensitivity:'base' }));
      sel.innerHTML='';
      const optAll=document.createElement('option'); optAll.value=''; optAll.textContent='全ユニット'; sel.appendChild(optAll);
      units.forEach(u=>{ const opt=document.createElement('option'); opt.value=u; opt.textContent=u; sel.appendChild(opt); });
      if(deckArr.length===0){
        sel.value='';
        sel.disabled=true;
        if(state.unitFilter){
          state.unitFilter='';
          rememberUnitFilter(state.qType, '');
        }
        return;
      }
      sel.disabled=false;
      if(state.unitFilter && !units.includes(state.unitFilter)){
        state.unitFilter='';
        rememberUnitFilter(state.qType, '');
      }
      sel.value = state.unitFilter || '';
    }
    function loadRememberedSettings(){
      const u=(localStorage.getItem(REMEMBER_USER_KEY)||'').trim();
      if(u){ state.user=u; const inp=document.getElementById('learner'); if(inp) inp.value=u; const pill=document.getElementById('user-pill'); if(pill) pill.textContent=`👤 ${u}`; }
      const qt=(localStorage.getItem(REMEMBER_QTYPE_KEY)||'').trim();
      const qs=document.getElementById('qtype');
      if(qt){ state.qType=qt; if(qs) qs.value=qt; }
      const levelSel = document.getElementById('level-filter');
      const rememberedLevel = (localStorage.getItem(REMEMBER_LEVEL_KEY)||DEFAULT_LEVEL).trim();
      const normalizedLevel = LEVEL_ORDER.includes(rememberedLevel) ? rememberedLevel : DEFAULT_LEVEL;
      state.levelMax = normalizedLevel;
      if(levelSel){ levelSel.value = normalizedLevel; }
      state.unitFilter = getRememberedUnitFilter(state.qType);
      const unitSel = document.getElementById('unit-filter');
      if(unitSel){ unitSel.value = state.unitFilter || ''; }
      state.endpoint=DEFAULT_ENDPOINT;
      populateUserSuggestions();
    }
    function rememberSettings(){
      if(state.user) localStorage.setItem(REMEMBER_USER_KEY, state.user);
      if(state.qType) localStorage.setItem(REMEMBER_QTYPE_KEY, state.qType);
      localStorage.setItem(REMEMBER_LEVEL_KEY, state.levelMax || DEFAULT_LEVEL);
      rememberUnitFilter(state.qType, state.unitFilter||'');
      const raw=JSON.parse(localStorage.getItem(USER_SUGGEST_KEY)||'[]');
      const list=Array.isArray(raw)? raw.slice(0) : [];
      if(state.user){
        const i=list.indexOf(state.user); if(i!==-1) list.splice(i,1);
        list.unshift(state.user);
        if(list.length>20) list.length=20;
        localStorage.setItem(USER_SUGGEST_KEY, JSON.stringify(list));
      }
      populateUserSuggestions();
    }

    /********** ストレージ（ローカル） **********/
    const storeKey=(u)=>`quiz:${u}`;
    const wrongKey=(u,t)=>`quiz:${u}:wrong:${t}`;
    function getHistory(){ const raw=JSON.parse(localStorage.getItem(storeKey(state.user))||'{}'); return raw.history||[]; }
    function pushHistory(session){ const raw=JSON.parse(localStorage.getItem(storeKey(state.user))||'{}'); raw.history=raw.history||[]; raw.history.unshift(session); localStorage.setItem(storeKey(state.user), JSON.stringify(raw)); }
    function getWrongQueue(){ return JSON.parse(localStorage.getItem(wrongKey(state.user, state.qType))||'[]'); }
    function setWrongQueue(list){ localStorage.setItem(wrongKey(state.user, state.qType), JSON.stringify(list.slice(0,150))); }
    function addWrongLocal(item){ const q=getWrongQueue(); const key=item.id?`id:${item.id}`:`${item.en}__${item.jp}`; if(!q.some(x=>x.key===key)){ q.unshift({...item, key}); setWrongQueue(q); } }
    function removeFromWrongIfMatched(rec){ const q=getWrongQueue(); const key=rec.id?`id:${rec.id}`:null; let idx=-1; if(key){ idx=q.findIndex(x=>x.key===key); } if(idx===-1){ idx=q.findIndex(x=>x.en===rec.en && x.jp===rec.jp); } if(idx>-1){ q.splice(idx,1); setWrongQueue(q); } }

    /********** 画面切替 **********/
    function show(id){ ['setup','quiz','finished'].forEach(sec=>{ const el=$(`#${sec}`); if(!el) return; el.style.display = (sec===id)?'block':'none'; }); }

    /********** デッキ取得 **********/
    function deckByType(type){ return type==='reorder' ? BANK_REORDER : BANK_VOCAB; }
    function deck(){
      const all = deckByType(state.qType);
      if(state.mode==='review') return all;
      const maxLevelIdx = levelIndex(state.levelMax);
      const byLevel = all.filter(q=> levelIndex(q.level) <= maxLevelIdx);
      const shouldFilterByUnit = state.mode==='normal' || state.mode==='weak';
      const unit = shouldFilterByUnit ? (state.unitFilter || '') : '';
      if(!unit) return byLevel;
      return byLevel.filter(q=> normalizeUnit(q.unit) === unit);
    }

    function parseIsoDate(value){
      if(!value) return null;
      const date = new Date(value);
      return Number.isNaN(date.getTime()) ? null : date;
    }

    function isSameCalendarDay(a,b){
      if(!(a instanceof Date) || !(b instanceof Date)) return false;
      return a.getFullYear()===b.getFullYear() && a.getMonth()===b.getMonth() && a.getDate()===b.getDate();
    }

    /********** セット準備 **********/
    async function buildOrderFromBank(){
      const deckArr = deck();
      const n = Math.min(state.totalPerSet, deckArr.length);

      // バケット：
      // A: サーバ記録で直近の回答が正解の問題
      // B: それ以外（誤答または未回答）の問題
      const bucketA = [];
      const bucketB = [];

      // サーバから各問題の統計を取得
      const stats = await Promise.all(
        deckArr.map(q=>{
          if(!state.user || !q.id) return Promise.resolve(null);
          const url = `/api/stats?user=${encodeURIComponent(state.user)}&id=${encodeURIComponent(q.id)}&subject=${encodeURIComponent(SUBJECT)}`;
          return fetch(url,{cache:'no-store'})
            .then(r=>r.ok?r.json():null)
            .catch(()=>null);
        })
      );

      for(let i=0;i<deckArr.length;i++){
        const s = stats[i];
        if(!s || typeof s !== 'object'){ bucketB.push({idx:i, streak:0}); continue; }
        const lastWrong = parseIsoDate(s.lastWrongAt);
        const lastCorrect = parseIsoDate(s.lastCorrectAt);
        const recoveredSameDay = lastWrong && lastCorrect && isSameCalendarDay(lastWrong, lastCorrect) && lastCorrect.getTime() >= lastWrong.getTime();
        if(recoveredSameDay){ bucketB.push({idx:i, streak:0}); continue; }
        const streak = s.streak||0;
        const ans = s.answered||0;
        const ok = s.correct||0;
        const accuracy = ans? (ok/ans) : 0;
        if(streak>0){
          bucketA.push({ idx:i, streak, accuracy, rand:Math.random() });
        }else{
          bucketB.push({idx:i, streak:0});
        }
      }

      // 連続正解数の少ない順 → 正解率の低い順 → 乱数
      const compareA = (a, b) =>
        (a.streak - b.streak) || (a.accuracy - b.accuracy) || (a.rand - b.rand);

      const order = [];
      bucketA.sort(compareA);
      if(bucketA.length>0){
        const picked = bucketA.shift();
        order.push({ idx:picked.idx, bucket:'A', streak:picked.streak });
      }

      const B = shuffle(bucketB); // ランダム
      while(order.length < n && B.length){
        const b = B.shift();
        order.push({ idx:b.idx, bucket:'B', streak:b.streak });
      }

      bucketA.forEach(x=>x.rand=Math.random());
      bucketA.sort(compareA);
      while(order.length < n && bucketA.length){
        const next = bucketA.shift();
        order.push({ idx:next.idx, bucket:'A', streak:next.streak });
      }

      return order;
    }






    function buildOrderFromWrong(strategy='all'){
      const wrong=getWrongQueue();
      if(wrong.length===0) return [];
      const need = Math.min(state.totalPerSet, wrong.length);
      let pool = [];
      if(strategy==='recent'){
        const cutoff = Date.now() - 7*24*3600*1000;
        const recent = wrong.filter(x=> x.at && (new Date(x.at).getTime()>=cutoff))
                            .sort((a,b)=> new Date(b.at)-new Date(a.at));
        pool = recent.slice(0, need);
        if(pool.length < need){
          const rest = wrong.filter(x=> !pool.includes(x));
          pool = pool.concat(rest.slice(0, need - pool.length));
        }
      }else{
        pool = wrong.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]).slice(0, need);
      }
      window.__REVIEW_DECK__ = pool.map(w=>({ ...w }));
      return [...window.__REVIEW_DECK__.keys()];
    }

    // === 成績インデックス（ローカル）: 過去データから弱点抽出 ===
    const PERF_KEY = (u)=>`quiz:${u}:perf`;
    const qKeyOf = (q)=> q.id? `id:${q.id}` : `${q.type}:${q.en}__${q.jp}`;
    function loadPerf(){ return JSON.parse(localStorage.getItem(PERF_KEY(state.user))||'{}'); }
    function savePerf(p){ localStorage.setItem(PERF_KEY(state.user), JSON.stringify(p)); }
    function noteAttempt(q, correct, at, mode){
      if(mode==='review') return; // 復習モードは記録しない
      const p = loadPerf();
      const k = qKeyOf(q);
      const rec = p[k] || { id:q.id||null, type:q.type, jp:q.jp, en:q.en, unit:q.unit||null, attempts:[] };
      rec.attempts.push({ correct: !!correct, at });
      const cutoff = Date.now() - 30*24*3600*1000; // 30日でローテ
      rec.attempts = rec.attempts.filter(a=> new Date(a.at).getTime() >= cutoff);
      p[k]=rec; savePerf(p);
    }
    function updateQuestionStat(q, bucket){
      const elStreak = $('#stat-streak');
      const elAcc = $('#stat-accuracy');
      const elBucket = $('#stat-bucket');
      const elStage = $('#stat-stage');
      elBucket.textContent = bucket ? `バケット: ${bucket}` : 'バケット: --';
      elStage.textContent = 'ランク: --';
      if(!state.user || !q.id){
        elStreak.textContent='連続正解: --';
        elAcc.textContent='正解率: --';
        return;
      }
      fetch(`/api/stats?user=${encodeURIComponent(state.user)}&id=${encodeURIComponent(q.id)}&subject=${encodeURIComponent(SUBJECT)}`, {cache:'no-store'})
        .then(res=>res.ok?res.json():null)
        .then(data=>{
          if(!data){
            elStreak.textContent='連続正解: --';
            elAcc.textContent='正解率: --';
            elStage.textContent='ランク: --';
            return;
          }
          const ans=data.answered||0; const ok=data.correct||0;
          elStreak.textContent = `連続正解: ${data.streak||0}`;
          elAcc.textContent = ans? `正解率: ${Math.round((ok/ans)*100)}% (${ok}/${ans})` : '正解率: --';
          elStage.textContent = data.stage ? `ランク: ${data.stage}` : 'ランク: --';
        })
        .catch(()=>{
          elStreak.textContent='連続正解: --';
          elAcc.textContent='正解率: --';
          elStage.textContent='ランク: --';
        });
    }
    function weakCandidates(windowDays){
      const p = loadPerf();
      const cut = Date.now() - (windowDays*24*3600*1000);
      const list = [];
      const d = deck();
      for(const q of d){
        const k = qKeyOf(q);
        const rec = p[k];
        if(!rec || !rec.attempts || rec.attempts.length===0) continue;
        const arr = rec.attempts.filter(a=> new Date(a.at).getTime() >= cut);
        if(arr.length===0) continue;
        const wrong = arr.filter(a=>!a.correct).length;
        const acc = (arr.length - wrong)/arr.length;
        list.push({ q, acc, attempts: arr.length, wrong, lastAt: arr[arr.length-1].at });
      }
      // 低正答率 → 試行回数多 → 最近 の順
      list.sort((a,b)=> (a.acc - b.acc) || (b.attempts - a.attempts) || (new Date(b.lastAt)-new Date(a.lastAt)) );
      return list;
    }
    function buildOrderWeak(windowDays=7){
      const stats = weakCandidates(windowDays);
      if(stats.length===0) return [];
      const pick = stats.slice(0, Math.min(state.totalPerSet, stats.length)).map(s=>s.q);
      window.__WEAK_DECK__ = pick;
      return pick.map((_,i)=>i);
    }

    async function startSet(){
      try{ await ensureQuestions(); }catch(e){ alert(e.message||e); return; }
      const fullDeck = deckByType(state.qType);
      if(!fullDeck.length){ alert(`この出題タイプの問題がありません。/data/${SUBJECT}/questions.json をご確認ください。`); show('setup'); return; }
      const filteredDeck = deck();
      if(state.mode==='normal' && !filteredDeck.length){
        alert('選択したレベル／ユニットの条件に合う問題がありません。条件を見直してください。');
        show('setup');
        return;
      }
      state.qIndex=0; state.correct=0; state.wrong=0; state.answered=[]; state.reviewed=[]; state.graded=false;
      $('#stat-correct').textContent='0'; $('#stat-wrong').textContent='0';
      if(state.mode==='review'){
        const ord = buildOrderFromWrong(state.reviewStrategy||'all');
        if(ord.length===0){ alert('復習する問題がありません。まずは通常モードで間違いをためましょう。'); show('setup'); return; }
        state.order = ord.map(i=>({idx:i, bucket:null, streak:0}));
      }else if(state.mode==='weak'){
        const ord = buildOrderWeak(state.weakWindowDays||7);
        if(ord.length===0){ alert('弱点候補が見つかりません（最近のデータが不足）。通常モードで解いてデータを増やしましょう。'); show('setup'); return; }
        state.order = ord.map(i=>({idx:i, bucket:null, streak:0}));
      }else{
        state.order = await buildOrderFromBank();
      }
      show('quiz'); startTimer(); renderQuestion();
    }

    /********** 出題＆UI **********/
    function getCurrentQuestion(){
      const entry = state.order[state.qIndex];
      const idx = entry.idx;
      if(state.mode==='review') return window.__REVIEW_DECK__[idx];
      if(state.mode==='weak') return window.__WEAK_DECK__[idx];
      return deck()[idx];
    }

    function startTimer(){ state.startedAt=Date.now(); if(state.timerId) clearInterval(state.timerId); state.timerId=setInterval(()=>{ const sec=Math.floor((Date.now()-state.startedAt)/1000); $('#timer').textContent=`⏱ ${fmtTime(sec)}`; }, 250); }
    function stopTimer(){ if(state.timerId){ clearInterval(state.timerId); state.timerId=null; } }

    function renderQuestion(){
      const entry = state.order[state.qIndex];
      const q = getCurrentQuestion();
      updateQuestionStat(q, entry.bucket);
      state.graded = false;
      $('#status').textContent = `Q ${state.qIndex+1}/${state.order.length}${state.mode==='review'?'（復習）':''}`;
      $('#explain').textContent='';

      if(state.qType==='reorder'){
        $('#ui-reorder').style.display='block';
        $('#ui-vocab').style.display='none';
        const basePrompt = q.jp || '<span class="muted">語順を並べ替えましょう</span>';
        $('#prompt').innerHTML = basePrompt;
        $('#btn-hint').disabled = !q.tip;
        const target=$('#target'); const bank=$('#bank'); target.innerHTML=''; bank.innerHTML='';
        let chunks = q.chunks.slice();
        if(entry.streak >= HARD_STREAK && q.wrong && q.wrong.length>0){
          const w = q.wrong[Math.floor(Math.random()*q.wrong.length)];
          chunks = chunks.concat(w);
        }
        chunks = shuffle(chunks);
        chunks.forEach((c,i)=>{
          const chip=document.createElement('button'); chip.className='chip'; chip.setAttribute('data-text',c); chip.textContent=`${i+1}. ${c}`;
          chip.onclick=()=>placeChip(chip); bank.appendChild(chip);
          chip.draggable=true; chip.ondragstart=e=>{ e.dataTransfer.setData('text/plain', c); chip.classList.add('dragging'); };
          chip.ondragend=()=>chip.classList.remove('dragging');
        });
        $('#target').ondragover=e=>{ e.preventDefault(); };
        $('#target').ondrop=e=>{ e.preventDefault(); const text=e.dataTransfer.getData('text/plain'); const src=[...$$('#bank .chip')].find(ch=>ch.getAttribute('data-text')===text && !ch.classList.contains('used')); if(src) placeChip(src); };
        $('#btn-next').disabled = true;
      } else {
        $('#ui-reorder').style.display='none';
        $('#ui-vocab').style.display='block';
        $('#prompt').innerHTML = `意味: <b>${q.jp}</b>`;
        $('#vocab-tip').innerHTML = '';
        $('#btn-hint').disabled = !q.tip;
        const inp = $('#vocab-input'); inp.value=''; inp.focus();
        $('#btn-next').disabled = false; // 入力だけなので次へボタンは常に押せる（採点は1回）
      }
    }

    function showHint(){
      const q = getCurrentQuestion();
      if(!q.tip) return;
      if(state.qType==='reorder'){
        const base = q.jp || '<span class="muted">語順を並べ替えましょう</span>';
        $('#prompt').innerHTML = `${base}<br><span class="muted">ヒント: ${q.tip}</span>`;
      } else {
        $('#vocab-tip').innerHTML = `ヒント: ${q.tip}`;
      }
    }

    function placeChip(chip){ if(chip.classList.contains('used')) return; chip.classList.add('used'); const btn=document.createElement('button'); btn.className='chip'; btn.textContent=chip.getAttribute('data-text'); btn.onclick=()=>{ btn.remove(); chip.classList.remove('used'); updateNextState(); }; $('#target').appendChild(btn); updateNextState(); }
    function undo(){ if(state.qType!=='reorder') return; const t=$$('#target .chip'); const last=t[t.length-1]; if(!last) return; const text=last.textContent; last.remove(); const bankChip=[...$$('#bank .chip')].find(c=>c.getAttribute('data-text')===text); if(bankChip) bankChip.classList.remove('used'); updateNextState(); }
    function clearAnswer(){ if(state.qType==='reorder'){ $$('#target .chip').forEach(n=>n.remove()); $$('#bank .chip').forEach(n=>n.classList.remove('used')); updateNextState(); } else { $('#vocab-input').value=''; $('#vocab-input').focus(); } }

    function currentAnswer(){ if(state.qType==='reorder'){ return [...$('#target').children].map(x=>x.textContent).join(' ');} return $('#vocab-input').value||''; }
    function updateNextState(){ if(state.qType==='reorder'){ $('#btn-next').disabled = state.graded ? false : true; } }

    function buildFeedbackDetail(q, includeTip=false){
      const lines = [];
      if(q.explain) lines.push(q.explain);
      if(includeTip && q.tip) lines.push(q.tip);
      if(lines.length===0) return '';
      return '<br>' + lines.map(text=>`<span class="muted">${text}</span>`).join('<br>');
    }

    function formatCorrectAnswers(list){
      const answers = (Array.isArray(list)? list : [list]).filter(Boolean);
      if(!answers.length) return '<span class="muted">（正解未設定）</span>';
      if(answers.length===1) return `<b>${answers[0]}</b>`;
      return answers.map(ans=>`<b>${ans}</b>`).join('<br><span class="muted">または</span> ');
    }

    /********** 採点・進行 **********/
    function checkAnswer(){
      if(state.graded) return; // 二重加算防止
      const q = getCurrentQuestion();

      const answerList = (Array.isArray(q.answers) && q.answers.length) ? q.answers : [q.en];
      let ans, correct;
      if(state.qType==='reorder'){
        const keepPunc = true; // 並び替えでは文末記号を保持する
        const normalizedAns = normalizeEndPunc(normalizeSpaces(currentAnswer()), keepPunc);
        ans = normalizedAns? normalizedAns.charAt(0).toUpperCase()+normalizedAns.slice(1) : normalizedAns;
        const normalizedAnswers = answerList.map(a=>normalizeEndPunc(normalizeSpaces(a), keepPunc));
        const normalizedAnsLower = typeof normalizedAns === 'string' ? normalizedAns.toLowerCase() : normalizedAns;
        const normalizedAnswersLower = normalizedAnswers.map(a=>typeof a === 'string' ? a.toLowerCase() : a);
        correct = normalizedAnswersLower.includes(normalizedAnsLower);
      } else { // vocab
        ans = normalizeWord(currentAnswer());
        const normalizedAnswers = answerList.map(a=>normalizeWord(a));
        correct = normalizedAnswers.includes(ans);
      }

      const record = {
        type: state.qType,
        id: q.id||null,
        unit: q.unit||null,
        userAnswer: ans,
        correct,
        setIndex: state.setIndex, qIndex: state.qIndex, mode: (state.mode||'normal'),
        at: nowISO()
      };

      if(correct){
        state.correct++; $('#stat-correct').textContent = state.correct;
        const detail = buildFeedbackDetail(q, false);
        $('#explain').innerHTML = `✅ 正解！ <span class="muted">${ans}</span>${detail}`;
        removeFromWrongIfMatched({id:q.id, jp:q.jp, en:q.en});
      } else {
        state.wrong++; $('#stat-wrong').textContent = state.wrong;
        const detail = buildFeedbackDetail(q, true);
        const answersMarkup = formatCorrectAnswers(answerList);
        $('#explain').innerHTML = state.qType==='reorder'
          ? `❌ 不正解。 正解: ${answersMarkup}${detail}`
          : `❌ 不正解。 正解: ${answersMarkup}${detail}`;
        // 復習用には詳細保持
        addWrongLocal({ type:state.qType, id:q.id||null, unit:q.unit||null, level:q.level||DEFAULT_LEVEL, jp:q.jp, en:q.en, chunks:q.chunks, tip:q.tip||'', explain:q.explain||'', userAnswer: ans, at: record.at });
      }

      (state.mode==='review'? state.reviewed : state.answered).push(record);
      noteAttempt(q, correct, record.at, state.mode);
      updateQuestionStat(q, state.order[state.qIndex].bucket);
      state.graded = true;
      $('#btn-next').disabled = false;
    }

    function nextQuestion(){
      if(!state.graded) checkAnswer();
      state.qIndex++;
      if(state.qIndex >= state.order.length){ finishSet(); }
      else { renderQuestion(); }
    }

    function finishSet(){
      stopTimer();
      const total = state.order.length;
      const accuracy = total? Math.round((state.correct/total)*100):0;
      const seconds = Math.floor((Date.now()-state.startedAt)/1000);
      $('#summary').innerHTML = `正解 <b>${state.correct}</b> / ${total}（<b>${accuracy}%</b>）・所要時間 ${Math.floor(seconds/60)}分${seconds%60}秒`;
      show('finished');

      // --- このセットの誤答だけを抽出してボタンに渡す ---
      const srcDeck = (state.mode==='review') ? window.__REVIEW_DECK__
                    : (state.mode==='weak')  ? window.__WEAK_DECK__
                    : deck();

      // 解答記録（通常 or 復習）の qIndex は「state.order 上の位置」
      const records = (state.mode==='review') ? state.reviewed : state.answered;
      const missedObjs = records
        .filter(r=>!r.correct)
        .map(r=>{
          const idxInSrc = state.order[r.qIndex].idx;
          return srcDeck[idxInSrc];
        })
        .filter(Boolean);

      // 状態に保持して、ボタン表示を更新
      state.missedSetDeck = missedObjs;
      const btnReviewThis = document.getElementById('btn-review-thisset');
      if(btnReviewThis){
        const n = missedObjs.length;
        btnReviewThis.disabled = (n===0);
        btnReviewThis.textContent = n
          ? `❗このセットのまちがいで復習（${n}問）`
          : `❗このセットのまちがいで復習（0問）`;
      }

      const wireAnswered = state.answered.map(({type,id,unit,userAnswer,correct,setIndex,qIndex,mode,at})=>({type,id,unit,userAnswer,correct,setIndex,qIndex,mode,at}));
      const wireReviewed = state.reviewed.map(({type,id,unit,userAnswer,correct,setIndex,qIndex,mode,at})=>({type,id,unit,userAnswer,correct,setIndex,qIndex,mode,at}));
      const wireCorrect  = wireAnswered.filter(x=>x.correct);
      const wireMissed   = wireAnswered.filter(x=>!x.correct);
      const wireReviewMissed = wireReviewed.filter(x=>!x.correct);

      const sessionWire = {
        user: state.user,
        setIndex: state.setIndex,
        mode: state.mode||'normal',
        qType: state.qType,
        total,
        correct: state.correct,
        wrong: total - state.correct,
        accuracy,
        seconds,
        endedAt: nowISO(),
        answered: wireAnswered,
        correctItems: wireCorrect,
        missed: wireMissed,
        reviewed: wireReviewed,
        reviewMissed: wireReviewMissed
      };

      // ローカル履歴はサマリのみ（軽量）
      pushHistory({ user: state.user, setIndex: state.setIndex, mode: state.mode||'normal', qType: state.qType, total, correct: state.correct, wrong: total-state.correct, accuracy, seconds, endedAt: sessionWire.endedAt });

      const saveEl = document.getElementById('save-status');
      const url = state.endpoint || DEFAULT_ENDPOINT;
      if(url){
        saveEl.textContent = '結果送信: 送信中…';
        const payload = { ...sessionWire, subject: SUBJECT };
        console.log('[POST] results =>', url, payload);
        postJSON(url, payload).then(r=>{
          if(r.ok){ saveEl.innerHTML = '<span class="ok">結果送信: 成功</span>'; }
          else { saveEl.innerHTML = `<span class=\"ng\">結果送信: 失敗</span> ${r.status||r.error||''}`; }
        });
      } else {
        saveEl.textContent = '結果送信: URL未設定（ローカル保存のみ）';
      }
    }

    /********** イベント **********/
    document.getElementById('btn-start').onclick=async ()=>{
      try{
        state.user=(document.getElementById('learner').value||'guest').trim()||'guest';
        document.getElementById('user-pill').textContent=`👤 ${state.user}`;
        state.totalPerSet=Math.max(3,Math.min(20,parseInt(document.getElementById('count').value||5,10)));
        state.endpoint=DEFAULT_ENDPOINT;
        state.setIndex=0; state.mode='normal'; state.qType=document.getElementById('qtype').value||'reorder';
        const levelSel=document.getElementById('level-filter');
        if(levelSel){
          state.levelMax = normalizeLevel(levelSel.value||DEFAULT_LEVEL);
          levelSel.value = state.levelMax;
        }
        const unitSel=document.getElementById('unit-filter');
        if(unitSel){
          const selected=(unitSel.value||'').trim();
          if(BANK_REORDER.length || BANK_VOCAB.length || !state.unitFilter){
            state.unitFilter=selected;
          }
        }
        rememberSettings();
        await startSet();
      }catch(e){ alert('開始できません: '+(e.message||e)); }
    };

    document.getElementById('btn-review-thisset').onclick = async ()=>{
      const deck = (state.missedSetDeck||[]).map(q=>({ ...q }));
      await startSetCustom(deck);
    };

    // 弱点対策（過去7日）
    document.getElementById('btn-weak').onclick=async ()=>{
      try{
        state.user=(document.getElementById('learner').value||'guest').trim()||'guest';
        document.getElementById('user-pill').textContent=`👤 ${state.user}`;
        state.totalPerSet=Math.max(3,Math.min(20,parseInt(document.getElementById('count').value||5,10)));
        state.endpoint=DEFAULT_ENDPOINT;
        state.setIndex=0; state.mode='weak'; state.qType=document.getElementById('qtype').value||'reorder';
        const levelSel=document.getElementById('level-filter');
        if(levelSel){
          state.levelMax = normalizeLevel(levelSel.value||DEFAULT_LEVEL);
          levelSel.value = state.levelMax;
        }
        const unitSel=document.getElementById('unit-filter');
        if(unitSel){
          const selected=(unitSel.value||'').trim();
          if(BANK_REORDER.length || BANK_VOCAB.length || !state.unitFilter){
            state.unitFilter=selected;
          }
        }
        rememberSettings();
        await startSet();
      }catch(e){ alert('弱点対策を開始できません: '+(e.message||e)); }
    };
   
    // 入力欄変更で即保存＋サジェスト更新
    document.getElementById('learner').addEventListener('change', (e)=>{
      const v=(e.target.value||'').trim(); if(!v) return;
      state.user=v; document.getElementById('user-pill').textContent=`👤 ${v}`;
      rememberSettings();
    });
    document.getElementById('unit-filter').addEventListener('change', (e)=>{
      const v=(e.target.value||'').trim();
      state.unitFilter=v;
      rememberSettings();
    });
    document.getElementById('level-filter').addEventListener('change', (e)=>{
      const selected = normalizeLevel(e.target.value||DEFAULT_LEVEL);
      state.levelMax = selected;
      const levelSel = document.getElementById('level-filter');
      if(levelSel) levelSel.value = selected;
      renderUnitFilterOptions();
      const unitSel = document.getElementById('unit-filter');
      if(unitSel){ state.unitFilter = (unitSel.value||'').trim(); }
      rememberSettings();
    });
    document.getElementById('qtype').addEventListener('change', async (e)=>{
      const v=(e.target.value||'').trim(); if(!v) return;
      state.qType=v;
      state.unitFilter = getRememberedUnitFilter(state.qType);
      try{
        await ensureQuestions();
      }catch(err){
        console.error('ensureQuestions failed', err);
        alert('問題の読み込みに失敗: '+(err.message||err));
      }
      renderUnitFilterOptions();
      const sel=document.getElementById('unit-filter');
      if(sel){ state.unitFilter=(sel.value||'').trim(); }
      rememberSettings();
    });

    document.getElementById('btn-check').onclick=checkAnswer; document.getElementById('btn-next').onclick=nextQuestion; document.getElementById('btn-undo').onclick=undo; document.getElementById('btn-clear').onclick=clearAnswer; document.getElementById('btn-clear-vocab').onclick=()=>{ $('#vocab-input').value=''; $('#vocab-input').focus(); }; document.getElementById('btn-hint').onclick=showHint;
    document.getElementById('btn-speak').onclick=()=>{
      const q=getCurrentQuestion();
      if(!q) return;
      const text = (Array.isArray(q.answers) && q.answers.length) ? q.answers[0] : q.en;
      const u=new SpeechSynthesisUtterance(text);
      u.lang='en-US';
      u.rate=1.0;
      speechSynthesis.cancel();
      speechSynthesis.speak(u);
    };

    // 完了画面の遷移
      document.getElementById('btn-nextset').onclick=async ()=>{
        try{
          state.setIndex++;
          if(state.mode==='review'){ state.mode='normal'; }
          await startSet();
        }catch(e){
          alert('次セットを開始できません: '+(e.message||e));
        }
      };
    document.getElementById('btn-dashboard').onclick=()=>{ 
      try{ 
        const u = encodeURIComponent(state.user||'');
        window.location.href = `/admin?user=${u}`;
      }catch(e){ 
        alert('ダッシュボードへ移動できません: '+(e.message||e)); 
      } 
    };
    document.getElementById('btn-to-setup').onclick=()=>{ show('setup'); };

    // キーボード（Enterで採点/次へ＋iOSでキーボードを閉じる）
    window.addEventListener('keydown',(e)=>{
      if(document.getElementById('quiz').style.display==='none') return;
      if(state.qType==='reorder'){
        if(e.key>='1' && e.key<='9'){ const idx=parseInt(e.key,10)-1; const chips=$$('#bank .chip'); const chip=chips[idx]; if(chip) placeChip(chip); }
        else if(e.key==='Backspace'){ e.preventDefault(); undo(); }
      }
      if(e.key==='Enter'){
        e.preventDefault();
        if(!state.graded){ checkAnswer(); }
        else { nextQuestion(); }
        if(document.activeElement && document.activeElement.blur){ document.activeElement.blur(); }
      }
    });

    // 初期
    loadRememberedSettings();
    ensureQuestions().catch(err=>{ console.error('ensureQuestions failed at init', err); });
    show('setup');
  </script>
</body>
</html>
